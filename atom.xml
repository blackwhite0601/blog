<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yydcc-blog.github.io/</id>
    <title>永远的CC的博客</title>
    <updated>2022-02-15T09:29:47.552Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yydcc-blog.github.io/"/>
    <link rel="self" href="https://yydcc-blog.github.io/atom.xml"/>
    <subtitle>永远的CC，永远爱斯卡帝</subtitle>
    <logo>https://yydcc-blog.github.io/images/avatar.png</logo>
    <icon>https://yydcc-blog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 永远的CC的博客</rights>
    <entry>
        <title type="html"><![CDATA[线段树，从入门到退坑]]></title>
        <id>https://yydcc-blog.github.io/post/xian-duan-shu-cong-ru-men-dao-tui-keng/</id>
        <link href="https://yydcc-blog.github.io/post/xian-duan-shu-cong-ru-men-dao-tui-keng/">
        </link>
        <updated>2022-02-15T08:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part0前言">Part0：前言</h1>
<blockquote>
<p>如果你在考提高组前一天还在问这个问题，那么你会与一等奖失之交臂；如果你还在冲击普及组一等奖，那么这篇博客会浪费你人生中宝贵的5~20分钟。</p>
</blockquote>
<h1 id="part1概念引入建树以区间求和为例">Part1：概念引入+建树（以区间求和为例）</h1>
<h2 id="part11概念引入">Part1.1：概念引入</h2>
<p>线段树，顾名思义，用线性的方式保存一颗二叉树。</p>
<p>举个例子：</p>
<p>有一串数<code>1 2 3 4 5 6 7 8 9</code></p>
<p>那么构造出的线段树就为：</p>
<pre><code class="language-cpp">                     1(123456789)
          2(1234)                    3(56789)
   4(12)       5(34)          6(56)           7(789)
8(1) 9(2)     10(3) 11(4)   12(5) 13(6)      14(7) 15(89)
                                                  16(8) 17(9)
</code></pre>
<p>其中括号内的数表示当前这个下标维护的范围。</p>
<h2 id="part12建树">Part1.2：建树</h2>
<p>用递归的方法建树。<code>void build(int p,int l,int r)</code></p>
<p>其中<code>p</code>表示下标，<code>l r</code>表示区间的范围。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，说明此时为叶子节点，直接赋值。</p>
<p>否则将区间分为两个，分别建树，下标为<code>*2</code>和<code>*2+1</code>。</p>
<p>最后维护各节点的信息，为它的两个子节点的和。</p>
<pre><code class="language-cpp">void build(int p,int l,int r){
    if(l==r){tree[p]=a[l];return ;}
    int mid=(l+r)&gt;&gt;1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    push_up(p);//维护信息
}
</code></pre>
<h1 id="part2区间查询修改以区间求和为例">Part2：区间查询+修改（以区间求和为例）</h1>
<h2 id="part21区间查询">Part2.1：区间查询</h2>
<p>递归法查询。</p>
<p>如果查询区间在当前区间中，返回线段树数组中当前下标所对应的值。</p>
<p>不然将查询分成两部分。</p>
<p>如果有一部分在左区间，就将左区间的查询结果加上。右区间同理。</p>
<p>最终返回左区间和右区间的查询结果之和即可。</p>
<pre><code class="language-cpp">int search(int i,int l,int r){
    if(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值
        return tree[i].sum;
    if(tree[i].r&lt;l || tree[i].l&gt;r)  return 0;//如果这个区间和目标区间毫不相干，返回0
    int s=0;
    if(tree[i*2].r&gt;=l)  s+=search(i*2,l,r);//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子
    if(tree[i*2+1].l&lt;=r)  s+=search(i*2+1,l,r);//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子
    return s;
}
</code></pre>
<h2 id="part22区间修改">Part2.2：区间修改</h2>
<p>和区间查询类似。</p>
<pre><code class="language-cpp">void add(int i,int dis,int k){
    if(tree[i].l==tree[i].r){//如果是叶子节点，那么说明找到了
        tree[i].sum+=k;
        return ;
    }
    if(dis&lt;=tree[i*2].r)  add(i*2,dis,k);//在哪往哪跑
    else  add(i*2+1,dis,k);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;//返回更新
    return ;
}
</code></pre>
<h1 id="part-3标记操作到下一篇讲">Part 3：标记操作到下一篇讲</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows.h中到底有什么]]></title>
        <id>https://yydcc-blog.github.io/post/windowsh-zhong-dao-di-you-shi-me/</id>
        <link href="https://yydcc-blog.github.io/post/windowsh-zhong-dao-di-you-shi-me/">
        </link>
        <updated>2022-02-02T04:25:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一个">第一个：</h1>
<p>FindWindow根据窗口类名或窗口标题名来获得窗口的句柄，该函数返回窗口的句柄， 这个函数的定义是这样的 HWND WINAPI FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName);</p>
<p>第一个参数填窗口的类名，第二个填窗口的标题名，其实是不需要同时填两个参数的，也就是说，你只要知道窗口的类名或窗口的标题就可以了，没有的那个就用NULL代替。</p>
<p>比如现在有一个窗口名为&quot;无标题.txt - 记事本&quot;的记事本程序。那么我就可以用上面的函数获得这个窗口的句柄，那获得了这个窗口的句柄我可以干什么呢？作用可大了，因为很多操作窗口的函数，都需要窗口句柄作参数，如移动、改变窗口大小的MoveWindow函数，在这里举个例子，大家就更能体会到这个FindWindow的用法、用处。</p>
<p>FindWindow例子：已知一个窗口名称，写一个程序关闭该窗口，假设当前电脑正有一个窗口名为&quot;无标题.txt - 记事本&quot;的记事本程序运行</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;//API函数的头文件
int main() { 
    HWND wnd;//定义一个窗口句柄变量，用以存储找到的窗口句柄
    wnd=FindWindow(NULL,&quot;无标题.txt - 记事本&quot;);//获得窗口名为&quot;无标题.txt - 记事本&quot;的窗口句柄
    SendMessage(wnd,WM_CLOSE,0,0);//调用SendMessage函数，发送一个WM_CLOSE（关闭）消息给wnd窗口句柄。
    return 0; 
} //如果要根据窗口类名来获得窗口句柄话，只要给函数的第一个参数填类名，第二个参数窗口名填NULL，即可，用Spy++可查看窗口类名。
</code></pre>
<h1 id="第二个">第二个：</h1>
<p>SendMessage根据窗口句柄发送一个消息给窗口</p>
<p>函数定义：LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）；</p>
<p>第一个参数是窗口句柄，第二参数个是消息类型，下面的消息表列举了所有消息，第三，四个参数是消息附带信息，解释依赖于消息类型，比如一个字符消息（WM_CHAR),那么第三个参数就储存有一个字符的ASCII码。</p>
<p>消息机制大家都应该知道吧，Windows是基于消息的系统，鼠标移动键盘按键都会产生消息。 接下来举一个例子，发送一个WM_CHAR消息给窗口，也就是模仿键盘按键，接收消息的窗口依旧以&quot;无标题.txt - 记事本&quot;为例： SendMessage例子：模仿键盘按键</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&quot;无标题.txt - 记事本&quot;);
    while(1) { 
        SendMessage(wnd,WM_CHAR,WPARAM('a'),0); 
        Sleep(300); 
    }
    return 0; 
} 
</code></pre>
<p>呵呵上面的例子是不是没用，这是为什么呢，哪里出错了吗？错倒是没有错，只是窗口句柄有问题，消息发送给了主窗口。接收消息的窗口不对。记事本窗口界面有些有什么东西呢？菜单，编辑框，状态栏等控件，控件也是窗口，既然是窗口，那当然它们也有窗口句柄，而在记事本里是在哪里打字的？编辑框控件里打字的嘛！所以消息应该发送编辑框控件，那如何获得记事本里编辑框控件的窗口句柄呢？用FindWindow吗？不知道编辑框窗口标题名，类名也不知道，当然也有其它方法获取编辑框窗口标题名和窗口类名，如Spy++。关于如何获得编辑框句柄，将在以后的函数中会有介绍，这里我们就用WindowFromPoint这个函数来获取，这个函数获取窗口句柄的方法比较笨，（相对于我这个例子来说），这个函数是根据什么来获取窗口句柄的呢？根据屏幕坐标点，如屏幕坐标点20，20，当前是哪个窗口占有，就返回哪个窗口的句柄。有了这个函数，我们还需要一个函数GetCursorPos获取鼠标当前位置（针对于屏幕）； 可行的例子：模仿键盘按键：</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int main() { 
    POINT curpos;//一个可储存坐标点的结构体变量，x横坐标，y,纵坐标，如curpos.x curpos.y
    while(1) { 
        GetCursorPos(&amp;curpos);//获取当前鼠标的位置，位置将储存在curpos里。
        HWND hWnd = WindowFromPoint(curpos);//根据curpos所指的坐标点获取窗口句柄
        SendMessage(hWnd,WM_CHAR,WPARAM('g'),0);//发送一个字符（按键）消息g给当前鼠标所指向的窗口句柄
        Sleep(300);//睡眠三百毫秒，相当于等待三分之一秒} } 这个程序一运行后，只要把鼠标指向要输入字符的窗口句柄，那么就相当于键盘每三分之一秒按了一个g键，试试吧！ 如果这样觉得模仿键盘按键太麻烦的话，那么就用keybd_event这个函数，这个专门用于模仿键盘按键的，关于怎么用，自己百度一搜，就知道了。既然SendMessage能模仿键盘按键的话，那也能模仿鼠标左击，右击。而此时SendMessage函数第三，四个参数的解释就是储存有鼠标左击，右击时的位置。如模仿鼠标右击，想一想，一次鼠标右击有哪几步，分别是鼠标右键按下，鼠标右键松开，如果你按下鼠标右键不松开，那它是不是鼠标右击，不是的，直到你松开鼠标右键，才能算是一次完整的鼠标右击.鼠标右键按下的消息类型是“WM_RBUTTONDOWN”，右键松开的消息是“WM_RBUTTONUP”，那么一次完整的鼠标右击应该是： 
        SendMessage(wnd,WM_RBUTTONDOWN,0,0);//鼠标右键按下,第三，四个参数说明了鼠标按下时的位置Sleep(100);//间隔100毫秒
        SendMessage(wnd,WM_RBUTTONUP,0,0);//鼠标右键松开同样，也有一个专门模仿鼠标动作的函数，mouse_event这个函数，可以模仿鼠标的移动，单击，双击等。以后会有专门介绍。
    }
    return 0;
}
</code></pre>
<h1 id="第三个">第三个：</h1>
<p>GetCursorPos获取鼠标当前位置（屏幕） 这个函数在SendMessage函数有介绍，这里仅举一个例子，在界面里不停的输出鼠标当前位置。</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
#include&lt;stdio.h&gt;
int main() { 
    POINT curpos;
    while(1) { 
        GetCursorPos(&amp;curpos); 
        printf(&quot;x:%d,y:%d&quot;,curpos.x,curpos.y); 
        Sleep(300); 
        printf(&quot;\n&quot;); 
    } 
    return 0;
}
</code></pre>
<h1 id="第四个">第四个：</h1>
<p>WindowFromPoint根据坐标点获得对应的窗口句柄 在SendMessage有解释，这里仅举一个例子，鼠标指向哪个窗口，就关闭哪个窗口。</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int mai() { 
    Sleep(2500);//等待一会儿，用于把鼠标移到其它窗口上去，避免指向本身进程的窗口，关掉自己的窗口。
    POINT curpos;
    while(1) { 
        GetCursorPos(&amp;curpos); 
        HWND wnd=WindowFromPoint(curpos); 
        SendMessage(wnd,WM_CLOSE,0,0); 
        Sleep(300); 
    }
    return 0; 
} 
</code></pre>
<h1 id="第五个">第五个：</h1>
<p>MoveWindow根据窗口句柄移动窗口，改变窗口大小 函数定义：BOOL MoveWindow( HWND hWnd, int X, int Y, intnWidth, int nHeight, BOOL bRepaint );</p>
<p>hWnd是要改变大小的窗口的句柄，x,y相对于屏幕的坐标，窗口左上角的位置与之相对应，nWidth和nHeight是窗口新的宽高，bRepaint指定窗口是否重画。</p>
<p>这里依旧以&quot;无标题.txt - 记事本&quot;为例子，改变这个窗口大小，并把窗口移到左上角去。</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&quot;无标题.txt - 记事本&quot;); 
    MoveWindow(wnd,0,0,220,120,NULL);
    return 0; 
}
</code></pre>
<h1 id="第六个">第六个：</h1>
<p>ShowWindow设置窗口显示状态，如隐藏，最大化，最小化 函数定义BOOL ShowWinow(HWND hWnd,int nCmdShow); SW_HIDE：隐藏窗口并激活其他窗口。第一个参数hWnd指明了窗口句柄，第二个参数指明了窗口的状态，现在给出第二个参数常用取值范围：</p>
<ul>
<li>SW_MAXIMIZE：最大化指定的窗口。</li>
<li>SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。</li>
<li>SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。</li>
<li>SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。</li>
<li>ShowWindow例子：程序运行后，在桌面上隐藏一个指定的窗口，并在4秒后再将其显示</li>
</ul>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&quot;无标题.txt - 记事本&quot;); 
    ShowWindow(wnd,SW_HIDE); 
    Sleep(5000); 
    ShowWindow(wnd,SW_SHOW);
    return 0; 
} 
</code></pre>
<h1 id="第七个">第七个：</h1>
<p>SetCursorPos设置鼠标的位置、把鼠标移动到指定的位置</p>
<p>函数定义：BOOL SetCursorPos(int x,int y);</p>
<p>这个函数的两个参数我想大家应该知道是什么意思吧，屏幕的坐标点。 直接看例子：</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
int main() { 
    int sec=0;
    while(sec&lt;200) { 
        SetCursorPos(rand()%1024,rand()%768);//随机设置鼠标的位置
        Sleep(20); 
        sec++; 
    }
    return 0; 
}
</code></pre>
<h1 id="第八个">第八个：</h1>
<p>CopyFile复制一个文件</p>
<p>如何复制一个文件，比如，我要把E盘的abb.txt的文本文件复制到d盘的zhengyong.txt,则调用语句 CopyFile(&quot;e:\abb.txt&quot;,&quot;d:\zhengyong.txt&quot;,FALSE);即可。</p>
<p>第三个参数有以下说明： 如果设为TRUE（非零），那么一旦目标文件已经存在，则函数调用会失败。否则目标文件会被覆盖掉。</p>
<h1 id="第九个">第九个：</h1>
<p>DeleteFile删除一个文件 如何删除一个文件，语句：DeleteFile(&quot;e\abb.txt&quot;);既是删除 如果目标为隐藏或只读，则无用。</p>
<h1 id="第十个">第十个：</h1>
<p>CreateDirectory创建一个文件夹（目录）</p>
<p>假如E盘下什么文件也没有 CreateDirectory(&quot;e:\aaa\bbb&quot;,NULL);这样是错的，不能同时建两个文件，除非E盘下已经有了个aaa文件夹了。</p>
<p>这样是对的CreateDirectory(&quot;e:\aaa&quot;,NULL);</p>
<h1 id="第十一个">第十一个：</h1>
<p>GetClientRect获得窗口大小(客户区）<br>
看例子：</p>
<pre><code class="language-cpp">#include&lt;windows.h&gt;
#include&lt;stdio.h&gt;
int main(int argc, char* argv[]) { 
    HWND wnd;
    while(1) { 
        wnd=FindWindow(NULL,&quot;无标题.txt - 记事本&quot;); 
        RECT rect;//专门用来存储窗口大小
        GetClientRect(wnd,&amp;rect);//获取窗口大小
        printf(&quot;%d,%d,%d,%d\n&quot;,rect.left,rect.top,rect.right,rect.bottom);//输出窗口大小，试着用鼠标改变窗口大小
        Sleep(300);
     }
 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LIVE-活着]]></title>
        <id>https://yydcc-blog.github.io/post/live-huo-zhao/</id>
        <link href="https://yydcc-blog.github.io/post/live-huo-zhao/">
        </link>
        <updated>2022-01-31T13:48:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>by 黑_白（永远的CC）</p>
<h1 id="代码行数149行">代码行数：149行</h1>
<h1 id="更新日志">更新日志</h1>
<ul>
<li>第一个版本1️⃣</li>
<li>添加了不同人数🚻</li>
<li>添加了对作弊者的惩治☠️</li>
<li>添加了亡语👻</li>
<li>第二个版本2️⃣</li>
<li>避免了自杀🤡</li>
<li>添加了技能🎌</li>
</ul>
<h1 id="判定数字机制">判定数字机制</h1>
<p>第一个1/1<br>
第二个1/2<br>
第三个1/3<br>
第四个1/4<br>
第五个1/5<br>
第六个1/6</p>
<h1 id="技能列表">技能列表</h1>
<ul>
<li>冰冻：跳过杀人阶段</li>
<li>近视：只能杀编号相邻的人（没有编号相邻的人就杀不了QWQ）</li>
</ul>
<h1 id="游戏代码">游戏代码：</h1>
<pre><code class="language-cpp">//LIVE
#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
using namespace std;
void print(char a[]){for(int i=0;i&lt;strlen(a);i++){cout&lt;&lt;a[i];Sleep(10);}puts(&quot;&quot;);}
void cls(){system(&quot;cls&quot;);}
void pause(){system(&quot;pause&quot;);}
void hehe(){print(&quot;小朋友想走不当途径是不好的&quot;);print(&quot;你死了&quot;);exit(1);}
int f,a,last,live[10000],skill[10000];
int main(){
	srand(time(NULL));
	system(&quot;title LIVE-by black_white&quot;);
	system(&quot;MODE CON: COLS=50 LINES=30&quot;);
	std::srand(time(NULL));
	print(&quot;LIVE活着&quot;);pause();cls();
	print(&quot;by 黑_白（永远的CC）&quot;);pause();cls();
	printf(&quot;输入人数（推荐7人）：&quot;);
	cin&gt;&gt;last;
	if(last&lt;=0)hehe();
	for(int i=1;i&lt;=last;i++)live[i]=i;
	print(&quot;规则：一共n个人，每个人选择一个击杀目标，最后剩下的人胜利&quot;);pause();cls();
	print(&quot;游戏开始！&quot;);cls();
	printf(&quot;输入你的编号（1~n）：&quot;);
	cin&gt;&gt;a;cls();
	if(a==114514)print(&quot;成功开启人机对打！&quot;);
	else if(!(a&gt;=1&amp;&amp;a&lt;=last))hehe();
	cls();
	for(int I=1;;I++){
		cls();
		printf(&quot;--------------------------------------------------\n&quot;);
		printf(&quot;第%d个回合：\n&quot;,I);
		for(int i=1;i&lt;=last;i++){
			if(live[i]==0)continue;
			int Cnt=0;
			for(int j=1;j&lt;=last;j++)if(live[j]!=0)Cnt++;
			printf(&quot;还剩%d人\n&quot;,Cnt);
			printf(&quot;还活着的人：&quot;);
			for(int j=1;j&lt;=last;j++)if(live[j]!=0)printf(&quot;%d &quot;,live[j]);
			puts(&quot;&quot;);
			if(skill[i]==1){
				printf(&quot;%d号解冻\n&quot;,i);
				skill[i]=0;
				continue;
			}
			int mb=rand()%(last+1);
			while(live[mb]==0&amp;&amp;mb==i&amp;&amp;mb==0)mb=rand()%(last+1);
			if(a!=live[i])printf(&quot;%d选择了%d号\n&quot;,live[i],live[mb]);
			else{
				printf(&quot;你的目标是（输入0放弃猎杀）：&quot;);
				cin&gt;&gt;mb;
				bool ff=0;
				for(int j=1;j&lt;=last;j++)if(live[j]==mb)ff=1;
				if(!ff)hehe();
			}
			if(mb==0){
				print(&quot;他放弃了猎杀...&quot;);
				getch();
				continue;
			}
			if(skill[i]==2){
				if(mb-i&gt;1||mb-i&lt;-1){
					print(&quot;近视生效...&quot;);
					print(&quot;打不到目标...&quot;);
					skill[i]=0;
					continue;
				}
				skill[i]=0;
			}
			print(&quot;正在生成判定数字...\n&quot;);
			int pd[7],cnt=1;memset(pd,0,sizeof(pd));
			for(int j=1;j&lt;=6;j++){
				int t=rand()%j;
				if(t!=0)break;
				int tt=rand()%6;
				pd[cnt]=tt;
				cnt++;
			}
			printf(&quot;可判定的数字为：&quot;);
			for(int j=1;j&lt;=cnt;j++)pd[j]++,printf(&quot;%d &quot;,pd[j]);
			puts(&quot;&quot;);
			int s=rand()%3;
			if(s==0){
				print(&quot;有人篡改了判定数字。&quot;);
				pd[rand()%cnt+1]=rand()%6+1;
				printf(&quot;现可判定的数字为：&quot;);
				for(int j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,pd[j]);
				puts(&quot;&quot;);
			}
			getch();
			int sz=rand()%6;sz++;
			printf(&quot;%d号抛出了%d\n&quot;,live[i],sz);
			bool kill=0;
			for(int i=1;i&lt;=cnt;i++)
				if(sz==pd[i]){
					kill=1;
					break;
				}
			if(!kill)print(&quot;未杀死目标。\n&quot;),getch();
			else{
				int ttt=rand()%3;
				if(ttt&gt;0){
					live[mb]=0,print(&quot;成功杀死目标！\n&quot;);
					int tttt=rand()%2;
					if(tttt){
						int mb3=rand()%(last+1);
						while(live[mb3]==0&amp;&amp;mb3==i&amp;&amp;mb3==0)mb3=rand()%(last+1);
						printf(&quot;并发动技能：&quot;);
						int aa=rand()%2;
						if(aa==0){
							printf(&quot;冻结\n&quot;);
							printf(&quot;%d号被冻结了。\n&quot;,mb3);
							skill[mb3]=1;
						}else if(aa==1){
							printf(&quot;近视\n&quot;);
							printf(&quot;%d号近视了。\n&quot;,mb3);
							skill[mb3]=2;
						}
					}
					getch();
				}
				else{
					int mb2=rand()%(last+1);
					while(live[mb2]==0&amp;&amp;mb==mb2&amp;&amp;mb2==0)mb2=rand()%(last+1);
					printf(&quot;%d号复活了，并随机诅咒了%d号\n&quot;,live[mb],live[mb2]);
					getch();
					int tttt=rand()%2;
					if(tttt)printf(&quot;%d号死了\n&quot;,live[mb2]),live[mb2]=0;
					else printf(&quot;但他没死。\n\n&quot;);
					getch();
				}
			}
			int sum=0;
			for(int i=1;i&lt;=last;i++)if(live[i]!=0)sum++;
			if(sum==0){
				cls();
				print(&quot;每个人都倒下了...&quot;);
				print(&quot;无人胜利...&quot;);
				pause();
				return 0;
			}
			if(sum==1){
				for(int k=1;k&lt;=last;k++)
					if(live[k]!=0){
						printf(&quot;%d挺到了最后...\n&quot;,live[k]);
						if(k==a)print(&quot;你胜利了！&quot;);
						pause();
						return 0;
					}
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[人类沦陷-史诗级巨作]]></title>
        <id>https://yydcc-blog.github.io/post/ren-lei-lun-xian-shi-shi-ji-ju-zuo/</id>
        <link href="https://yydcc-blog.github.io/post/ren-lei-lun-xian-shi-shi-ji-ju-zuo/">
        </link>
        <updated>2022-01-31T03:55:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>黑_白(永远的CC)和段建泽共同出品。</p>
<h1 id="剧情">剧情</h1>
<h2 id="总剧情">总剧情</h2>
<blockquote>
<p>在千年以前，有一群人类被感染成了异种<br>
它们变得与常人不同,拥有更强大的力量与更强大的身体<br>
正常人类带着排斥接受着它们<br>
不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性<br>
人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石<br>
那次人类使出了全力对抗异种<br>
双方死伤惨重,人类花了200年才恢复过来<br>
而人类异种从此销声匿迹<br>
但现在，他们卷土重来了！！！<br>
作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？</p>
</blockquote>
<h2 id="分剧情1default最后堡垒">分剧情1：default:最后堡垒</h2>
<blockquote>
<p>这是人类最后的希望...<br>
你将坚守最后的城池，保卫身后那颗普蓝色的定界石<br>
这个阶段，史称<br>
最后堡垒!!!</p>
</blockquote>
<h2 id="分剧情2beta失落城邦">分剧情2：beta:失落城邦</h2>
<blockquote>
<p>人类从曾经摔倒的地方重新站起<br>
我们即将迎来第一场反击战!<br>
目光灼灼地望向前方，那曾是我们的家园<br>
这个阶段，史称<br>
失落城邦!!!</p>
</blockquote>
<h1 id="攻略">攻略</h1>
<pre><code>首先，你可以一直按0大约10次，攒到大约200
然后，你可以建一层护盾和一个哨兵塔，用来进攻
接着，继续攒钱，建高射炮来防御坦克及飞机
最后，只需要在建筑有破损时重建就行了
</code></pre>
<h1 id="各世界属性">各世界属性</h1>
<pre><code>造物主模式初始资源很多
生存模式资源中等
衰竭模式资源匮乏，每回合我方扣固定的100血量
</code></pre>
<h1 id="tips">Tips</h1>
<pre><code>高射炮不仅可以打飞机，把它压下来也可以打地面敌人！
迫击炮不仅可以打小兵，还能打敌方基地！
小兵打敌方基地的伤害十分可观。
导弹可以直接打对方的基地！
千万别让小兵接近你的基地，你的建筑十分危险！
激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！
护盾可以抵挡敌方的一次远程进攻哦！
克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用
岩石地雷可以在五回合后炸死敌方所有小兵哦！
晶坷垃是一种新型货币，不可与金币互换。
头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。
歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。
</code></pre>
<h1 id="游戏代码">游戏代码</h1>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;ctime&gt;
#include&lt;windows.h&gt;
#include&lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include&lt;mmsystem.h&gt;
//#pragma comment(lib, &quot;winmm.lib&quot;)
using namespace std;
int e,g=50,o1=3000,o2,e1=3000,e2,o1_max=3000,Lv;//金币：g, 晶坷垃 jkl
int s,l,sl,pj,dd,i,ts,k,tk,tke,tkk,xx,bt,gs,fj,fje,jjj,jjje;
int fk,jg,jk,hd,hde,jd,jde,zx,iii,pz,lzpz,pze,lzpze;
int dl,dle,jkl,jkl_kc,tt,zd,reblood,water;
//bdaguai
int Rand;
int dgsr;
int fy=15;
int gj=30;
int Rand2;
int hp=100;
int gwhp;
int moneyrand;
int jbrand;
int jklrand;
int mjrand;
int gfrand;
int grand;
int frand;
int dgcs;
//bdaguai
int hxcs;
//kaibx
int ksr;
int gbrand1;
int jklrand1;
int Rand1;
int gfrand1;
int grand1;
int frand1;
int kxcs;
int zjay;//买到终极宝箱（终极奥义）1
int fxjs;//买宝箱20次  （奉献精神）1
int gwlr;//杀死20个怪  （怪物猎人）1
int hxds;//买回血器5个 （回血大师）1
int dgds;//打死十级怪物（打怪大师）1
//（打怪大师）
//（终极奥义）
//（奉献精神）
//（怪物猎人）
//（回血大师）
//kaibx
//2048
int game_answer=0;
//2048
char d,ch;
bool beta;
string ssss;
//cj
int qqqq;
int www,jjj1,zzz,lll,vvv,hhh;
int cjcs;
//cj
/*设置背景颜色*/int setBackColor(unsigned char bColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;csbInfo);
    return SetConsoleTextAttribute(hd, (bColor &lt;&lt; 4) | (csbInfo.wAttributes&amp;~0xF0));
}
void appGotoXY(int x,int y)  //移动光标
{
    swap(x,y);
    CONSOLE_SCREEN_BUFFER_INFO    csbiInfo;
    HANDLE    hConsoleOut;
    hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsoleOut,&amp;csbiInfo);
    csbiInfo.dwCursorPosition.X = x;
    csbiInfo.dwCursorPosition.Y = y;
    SetConsoleCursorPosition(hConsoleOut,csbiInfo.dwCursorPosition);
}
void appGetXY() //得到光标位置
{
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO pBuffer;
    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hStdout, &amp;pBuffer);
    cout &lt;&lt; pBuffer.dwCursorPosition.X &lt;&lt;&quot; &quot;&lt;&lt; pBuffer.dwCursorPosition.Y &lt;&lt;endl;;
}
/*设置字体颜色*/int setTextColor(unsigned char fColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;csbInfo);
    return SetConsoleTextAttribute(hd, fColor | (csbInfo.wAttributes&amp;~0x0F));
}
void START(){
    appGotoXY(0,0);
    setBackColor(15);//大背景颜色
    for(int i=1;i&lt;=26*80;i++)
        cout&lt;&lt;&quot; &quot;;
    appGotoXY(0,0);
    cout&lt;&lt;&quot; &quot;;
    appGotoXY(20,19);
    setBackColor(7);//小背景颜色
    for(int i=1;i&lt;=42;i++)
        cout&lt;&lt;&quot; &quot;;
    setTextColor(0);//字体颜色
    appGotoXY(3,19);
    printf(&quot;┏━━━━┳━━━━┳━━━━┳━━━━┓\n&quot;);
    appGotoXY(4,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(5,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(6,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(7,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(8,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(9,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(10,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(11,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(12,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(13,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(14,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(15,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(16,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(17,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(18,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(19,19);
    printf(&quot;┗━━━━┻━━━━┻━━━━┻━━━━┛\n&quot;);
    //Sleep(100000);
    return ;
}
inline int Get_X(int x,int y){
    if(x==1)    return 5;
    if(x==2)    return 9;
    if(x==3)    return 13;
    if(x==4)    return 17;
}
inline int Get_Y(int x,int y){
    if(y==1)    return 24;
    if(y==2)    return 34;
    if(y==3)    return 44;
    if(y==4)    return 54;
}

void HideCursor(){//隐藏光标
    CONSOLE_CURSOR_INFO cursor_info = {1, 0};
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);
}

int a[5][5];
bool if_game_over(){
    for(int i=1;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++)
            if(!a[i][j])
                return 1;
    for(int i=2;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++){
            if(a[j][i]==a[j][i-1])
                return 1;
            if(a[i][j]==a[i-1][j])
                return 1;
        }
    return 0;
}
bool vis[20];

void Pr_a_num_with_color(int x){
    switch (x){/*
        1 = 蓝色   9  = 淡蓝色
        2 = 绿色   10 = 淡绿色
        3 = 湖蓝色 11 = 淡浅绿色
        4 = 红色   12 = 淡红色
        5 = 紫色   13 = 淡紫色
        6 = 黄色   14 = 淡黄色
        7 = 白色   15 = 亮白色*/
        case 2:setTextColor(9);printf(&quot;CE&quot;);setTextColor(0);break ;
        case 4:setTextColor(10);printf(&quot;RE&quot;);setTextColor(0);break ;
        case 8:setTextColor(11);printf(&quot;TLE&quot;);setTextColor(0);break ;
        case 16:setTextColor(12);printf(&quot;MLE&quot;);setTextColor(0);break ;
        case 32:setTextColor(13);printf(&quot;ILE&quot;);setTextColor(0);break ;
        case 64:setTextColor(14);printf(&quot;OLE&quot;);setTextColor(0);break ;
        case 128:setTextColor(15);printf(&quot;UKE&quot;);setTextColor(0);break ;
        case 256:setTextColor(1);printf(&quot;WA&quot;);setTextColor(0);break ;
        case 512:setTextColor(2);printf(&quot;AC&quot;);setTextColor(0);break ;
        case 1024:setTextColor(3);printf(&quot;AU&quot;);setTextColor(0);break ;
        case 2048:setTextColor(4);printf(&quot;AK&quot;);setTextColor(0);break ;
    }
}

void Pr_all_num(){
    for(int i=1;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++){
            int x=Get_X(i,j),y=Get_Y(i,j);
            appGotoXY(x,y);
            if(a[i][j]==0)
                printf(&quot;    &quot;);
            else{
                Pr_a_num_with_color(a[i][j]);
                //printf(&quot;%4d&quot;,a[i][j]);
            }
        }
    return ;
}
//**************************************************
bool clear_up(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=3;i&gt;=1;i--)
            for(int j=1;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i+1][j]!=0){
                    swap(a[i][j],a[i+1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_up(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_up())//没空间不能移动
        bb=0;
    for(int j=1;j&lt;=4;j++){
        int i=1;
        while(i&lt;4){
            if(!a[i+1][j])
                break ;
            if(a[i][j]!=a[i+1][j]){
                i++;
                continue ;
            }
            if(a[i][j]==a[i+1][j]){
                a[i][j]+=a[i+1][j]; game_answer+=a[i+1][j];
                a[i+1][j]=0;
                i+=2;
                bb=1;//可以合并
            }
        }
    }
    if(bb==0)//没空间又不能合并
        return 0;
    clear_up();
    return 1;
}
//**************************************************
bool clear_down(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=2;i&lt;=4;i++)
            for(int j=1;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i-1][j]!=0){
                    swap(a[i][j],a[i-1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_down(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_down())
        bb=0;
    for(int j=1;j&lt;=4;j++){
        int i=4;
        while(i&gt;1){
            if(!a[i-1][j])
                break ;
            if(a[i][j]!=a[i-1][j]){
                i--;
                continue ;
            }
            if(a[i][j]==a[i-1][j]){
                a[i][j]+=a[i-1][j];  game_answer+=a[i-1][j];
                a[i-1][j]=0;
                i-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_down();
    return 1;
}
//**************************************************
bool clear_left(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=1;i&lt;=4;i++)
            for(int j=3;j&gt;=1;j--)
                if(a[i][j]==0&amp;&amp;a[i][j+1]!=0){
                    swap(a[i][j],a[i][j+1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_left(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_left())
        bb=0;
    for(int i=1;i&lt;=4;i++){
        int j=1;
        while(j&lt;4){
            if(!a[i][j+1])
                break ;
            if(a[i][j]!=a[i][j+1]){
                j++;
                continue ;
            }
            if(a[i][j]==a[i][j+1]){
                a[i][j]+=a[i][j+1];  game_answer+=a[i][j+1];
                a[i][j+1]=0;
                j+=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_left();
    return 1;
}
//**************************************************
bool clear_right(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=1;i&lt;=4;i++)
            for(int j=2;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i][j-1]!=0){
                    swap(a[i][j],a[i][j-1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_right(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_right())
        bb=0;
    for(int i=1;i&lt;=4;i++){
        int j=4;
        while(j&gt;1){
            if(!a[i][j-1])
                break ;
            if(a[i][j]!=a[i][j-1]){
                j--;
                continue ;
            }
            if(a[i][j]==a[i][j-1]){
                a[i][j]+=a[i][j-1];  game_answer+=a[i][j-1];
                a[i][j-1]=0;
                j-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_right();
    return 1;
}
void END(){
    setBackColor(15);
    appGotoXY(21,30);
    char s_1[30]=&quot;游戏结束，您的得分为：&quot;;
    for(int i=0;i&lt;22;i++){
        cout&lt;&lt;s_1[i];
        Sleep(30);
    }
    Sleep(500);
    cout&lt;&lt;game_answer&lt;&lt;endl;
    g+=game_answer;
    Sleep(500);
    appGotoXY(22,30);
    char s_2[30]=&quot;请按任意键结束游戏。&quot;;
    for(int i=0;i&lt;20;i++){
        cout&lt;&lt;s_2[i];
        Sleep(30);
    }
}
void rlsb(){
    srand(time(0));
    HideCursor();//隐藏光标

    START();

    while(if_game_over()){
        //system(&quot;cls&quot;);
        //appGotoXY(0,0);

        int bb=0;//bb判断是否有空位
        for(int i=1;i&lt;=4;i++)
            for(int j=1;j&lt;=4;j++)
                if(!a[i][j])
                    bb=1;
        if(bb==1){
            int num_new=rand()%10+1;//新出现4还是2
            if(num_new==1)  num_new=4;
            else    num_new=2;
            int place_new=0,x=0,y=0;
            while(1){
                place_new=rand()%16+1;
                x=(place_new-1)/4+1,y=place_new%4+1;
                if(!a[x][y])
                    break ;
            }
            a[x][y]=num_new;
        }

        Pr_all_num();

    again:
        char ch_1=getch(),ch_2;
        if(ch_1!=-32){
            appGotoXY(20,30);
            char s_1[30]=&quot;您输入的字符不合法。&quot;;
            for(int i=0;i&lt;20;i++){
                cout&lt;&lt;s_1[i];
                Sleep(1);
            }
            Sleep(200);
            for(int i=1;i&lt;=19;i++)
                printf(&quot;\b \b&quot;);
            goto again;
        }
        ch_2=getch();
        if(ch_2==72)//up
            if(!do_up())
                goto again;
        if(ch_2==80)//down
            if(!do_down())
                goto again;
        if(ch_2==75)//left
            if(!do_left())
                goto again;
        if(ch_2==77)//right
            if(!do_right())
                goto again;
        appGotoXY(20,30);
        printf(&quot;您当前的总分为:%d&quot;,game_answer);
    }
    appGotoXY(20,30);
    printf(&quot;                     &quot;);
    END();
    return;
}
void cj(){
	system(&quot;cls&quot;);
	while(1){
		giao:
		system(&quot;cls&quot;);
		printf(&quot;0 退出\n&quot;);
		printf(&quot;1 查看几率\n&quot;);
		printf(&quot;2 抽奖\n&quot;);
		printf(&quot;纯属娱乐\n&quot;);
		scanf(&quot;%d&quot;,&amp;qqqq);
		if(qqqq==0) return;
		if(qqqq==1){
			system(&quot;cls&quot;);
			printf(&quot;200次%65几率抽到金色传说，%10抽中透明无敌\n&quot;);
			printf(&quot;100次%30几率抽到金色传说，%5抽中透明无敌\n&quot;);
			printf(&quot;50次%15几率抽到金色传说，%2抽中透明无敌\n&quot;);
			printf(&quot;10次%4几率抽到金色传说，%1抽中透明无敌\n&quot;);
			printf(&quot;5次%2几率抽中金色传说，%0.5抽中透明无敌\n&quot;);
			printf(&quot;1次%0.4几率抽中金色传说，%0.1抽中透明无敌\n&quot;);
			Sleep(5000);
		}else if(qqqq==2){
			printf(&quot;输入次数：\n&quot;);
			scanf(&quot;%d&quot;,&amp;cjcs);
			if(g&lt;cjcs*5){
				system(&quot;cls&quot;);
				printf(&quot;钱不够\n&quot;);
				Sleep(5000);
				goto giao;
			}else{
				system(&quot;cls&quot;);
				g-=cjcs*5;
				while(cjcs--){
					int x=std::rand()%1000*rand()%10000;
					if(x&lt;=1){
						printf(&quot;透明无敌！！！\n&quot;);
						MessageBox(NULL,&quot;你竟然抽中了爆率为%0.1的透明无敌！&quot;,&quot;透明无敌！&quot;,MB_OK);
						www++;
						goto f;
					}
					if(x&lt;=30){
						printf(&quot;金色传说！\n&quot;);
						MessageBox(NULL,&quot;金色传说&quot;,&quot;nb&quot;,MB_OK);
						jjj1++;
						goto f;
					}
					if(x&lt;=100){
						printf(&quot;紫色史诗\n&quot;);
						zzz++;
						goto f;
					}
					if(x&lt;=1000){
						printf(&quot;蓝色精英\n&quot;);
						lll++;
						goto f;
					}
					if(x&lt;=2000){
						printf(&quot;绿色普通\n&quot;);
						vvv++;
						goto f;
					}
					printf(&quot;灰色渣渣\n&quot;),hhh++;
					f:
					Sleep(30);
				}
				printf(&quot;透明无敌：%d\n&quot;,www);
				printf(&quot;金色传说：%d\n&quot;,jjj1);
				printf(&quot;紫色史诗：%d\n&quot;,zzz);
				printf(&quot;蓝色精英：%d\n&quot;,lll);
				printf(&quot;绿色普通：%d\n&quot;,vvv);
				printf(&quot;灰色渣渣：%d\n&quot;,hhh);
				Sleep(3000);
				goto giao;
			}
		}
	}
}
void kaibx(){
	bugo:
	if(kxcs&gt;=20&amp;&amp;fxjs!=1){
		fxjs=1;
		system(&quot;cls&quot;);
		printf(&quot;恭喜你取得了奉献精神的成就！！！\n&quot;);
		Sleep(5000);
		printf(&quot;奖励50晶坷垃,150金币&quot;);
		g+=150;
		jkl+=50;
		Sleep(5000);
	}
	system(&quot;cls&quot;);
	printf(&quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&quot;);
	printf(&quot;▉                宝箱                ▉\n&quot;);
	printf(&quot;▉1.  木头宝箱（10金币）              ▉\n&quot;);
	printf(&quot;▉2.  白银宝箱（20金币）              ▉\n&quot;);
	printf(&quot;▉3.  黄金宝箱（20金币，10晶坷垃）    ▉\n&quot;);
	printf(&quot;▉4.  钻石宝箱（50金币，20晶坷垃）    ▉\n&quot;);
	printf(&quot;▉5.  电击宝箱（100金币，40晶坷垃）   ▉\n&quot;);
	printf(&quot;▉6.  雷电宝箱（500金币，100晶坷垃）  ▉\n&quot;);
	printf(&quot;▉7.  终极宝箱（5000金币，500晶坷垃） ▉\n&quot;);
	printf(&quot;▉8.  退出                            ▉\n&quot;);
	printf(&quot;▉▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▉\n&quot;);
	printf(&quot;  金币：%d                              \n&quot;,g);
	printf(&quot;  晶坷垃：%d                            \n&quot;,jkl);
	printf(&quot;  开箱次数：%d                          \n&quot;,kxcs);
	printf(&quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&quot;);
	scanf(&quot;%d&quot;,&amp;ksr);
	if(ksr==0){
		return;
	}
	if(ksr==1){
		if(g&gt;=10){
			kxcs++;
			g-=10;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%15+5;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%6+2;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==2){
		if(g&gt;=20){
			kxcs++;
			g-=20;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%25+10;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%15+5;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==3){
		if(g&gt;=20 &amp;&amp; jkl&gt;=10){
			kxcs++;
			g-=20;
			jkl-=10;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%35+25;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%15+15;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%5+3;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%5+3;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==4){
		if(g&gt;=50 &amp;&amp; jkl&gt;=20){
			kxcs++;
			g-=50;
			jkl-=20;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%60+30;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%40+30;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%10+5;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%10+5;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==5){
		if(g&gt;=100 &amp;&amp; jkl&gt;=40){
			kxcs++;
			g-=100;
			jkl-=40;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%190+80;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%100+40;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%20+5;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%20+5;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==6){
		if(g&gt;=500 &amp;&amp; jkl&gt;=100){
			kxcs++;
			g-=500;
			jkl-=100;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%700+250;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%250+70;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%30+10;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%30+10;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==7){
		if(g&gt;=5000 &amp;&amp; jkl&gt;=500){
			if(zjay!=1){
				zjay=1;
				system(&quot;cls&quot;);
				printf(&quot;恭喜你取得了终极奥义的成就！！！\n&quot;);
				Sleep(5000);
				printf(&quot;奖励100晶坷垃,500金币&quot;);
				g+=500;
				jkl+=100;
				Sleep(5000);
			}
			kxcs++;
			g-=5000;
			jkl-=500;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%5000+3500;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%2000+700;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%100+30;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%100+30;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
}
void bdaguai(){
	shengli:
	if(dgcs&gt;=20&amp;&amp;gwlr!=1){
		gwlr=1;
		system(&quot;cls&quot;);
		printf(&quot;恭喜你取得了怪物猎人的成就！！！\n&quot;);
		Sleep(5000);
		printf(&quot;奖励20晶坷垃,100金币&quot;);
		g+=100;
		jkl+=20;
		Sleep(5000);
	}
	system(&quot;cls&quot;);
	printf(&quot;杀死怪物：%d\n&quot;,dgcs);
	printf(&quot;血量：%d\n&quot;,hp);
	printf(&quot;攻击力：%d\n&quot;,gj);
	printf(&quot;防御力：%d\n&quot;,fy);
	printf(&quot;1. 购买血瓶(10$/20hp)\n&quot;);
	printf(&quot;2. 返回\n&quot;);
	printf(&quot;3. 继续\n&quot;);
	scanf(&quot;%d&quot;,&amp;dgsr);
	if(dgsr==2) return;
	else if(dgsr==1){
		if(g&lt;20){
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(2000);
			goto shengli;
		}else{
			g-=10;
			hp+=20;
			system(&quot;cls&quot;);
			printf(&quot;回血成功\n&quot;);
			Sleep(2000);
			goto shengli;
		}
	}else if(dgsr==3){
		system(&quot;cls&quot;);
		if(hp&lt;=0){
			system(&quot;cls&quot;);
			printf(&quot;血量不足无法冒险\n&quot;);
			printf(&quot;1. 购买血瓶(10$/20hp)\n&quot;);
			printf(&quot;2. 返回\n&quot;);
			scanf(&quot;%d&quot;,&amp;dgsr);
			if(dgsr==2) return;
			else{
				if(g&lt;20){
					system(&quot;cls&quot;);
					printf(&quot;钱不够\n&quot;);
					Sleep(2000);
					goto shengli;
				}else{
					g-=10;
					hp+=20;
					system(&quot;cls&quot;);
					printf(&quot;回血成功\n&quot;);
					Sleep(2000);
					goto shengli;
				}
			}
			return;
		}
		Rand=std::rand()%10+1;
		gwhp=Rand*30;
		printf(&quot;你遇到了%d级怪物\n&quot;,Rand);
		printf(&quot;血量：%d\n&quot;,hp);
		printf(&quot;攻击力：%d\n&quot;,gj);
		printf(&quot;防御力：%d\n&quot;,fy);
		printf(&quot;怪物血量：%d\n&quot;,gwhp);
		printf(&quot;怪物攻击力：%d\n&quot;,Rand*10);
		printf(&quot;怪物防御力：%d\n&quot;,Rand*5);
		printf(&quot;1. 迎战\n&quot;);
		printf(&quot;2. 逃跑\n&quot;);
		scanf(&quot;%d&quot;,&amp;dgsr);
		if(dgsr==2) goto shengli;
		else{
			while(1){
				system(&quot;cls&quot;);
				printf(&quot;血量：%d\n&quot;,hp);
				printf(&quot;攻击力：%d\n&quot;,gj);
				printf(&quot;防御力：%d\n&quot;,fy);
				printf(&quot;怪物血量：%d\n&quot;,gwhp);
				printf(&quot;怪物攻击力：%d\n&quot;,Rand*10);
				printf(&quot;怪物防御力：%d\n&quot;,Rand*5);
				printf(&quot;1. 攻击\n&quot;);
				printf(&quot;2. 防御\n&quot;);
				scanf(&quot;%d&quot;,&amp;dgsr);
				if(dgsr==1){
					system(&quot;cls&quot;);
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&quot;cls&quot;);
						printf(&quot;怪物暴击\n&quot;);
						hp-=(Rand*20-fy);
						if(hp&lt;=0){
							system(&quot;cls&quot;);
							printf(&quot;KO\n&quot;);
							Sleep(2000);
							return;
						}
						Sleep(2000);
					}else{
						hp-=(Rand*10-fy);
						if(hp&lt;=0){
							system(&quot;cls&quot;);
							printf(&quot;KO\n&quot;);
							Sleep(2000);
							return;
						}
					}
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&quot;cls&quot;);
						printf(&quot;暴击&quot;);
						gwhp-=(gj*2-Rand*5);
						if(gwhp&lt;=0){
							dgcs++;
							if(Rand==10) dgds=1;
							system(&quot;cls&quot;);
							printf(&quot;胜利\n&quot;);
							mjrand=std::rand()%3;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&quot;奖励%d金币\n&quot;,jbrand);
								g+=jbrand;
							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+1;
								printf(&quot;奖励%d晶坷垃\n&quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d攻击力\n&quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d防御力\n&quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
						Sleep(2000);
					}else{
						gwhp-=(gj-Rand*5);
						if(gwhp&lt;=0){
							dgcs++;
							if(Rand==10 &amp;&amp; dgds!=1){
								dgds=1;
								system(&quot;cls&quot;);
								printf(&quot;恭喜你取得了打怪大师的成就！！！\n&quot;);
								Sleep(5000);
								printf(&quot;奖励200晶坷垃,1000金币&quot;);
								g+=1000;
								jkl+=200;
								Sleep(5000);
							}
							system(&quot;cls&quot;);
							printf(&quot;胜利\n&quot;);
							mjrand=std::rand()%5;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&quot;奖励%d金币\n&quot;,jbrand);
								g+=jbrand;

							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+5;
								printf(&quot;奖励%d晶坷垃\n&quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d攻击力\n&quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d防御力\n&quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
					}
				}
			}
		}
	}
}
void xs(char ccc){
	cout&lt;&lt;&quot;金币数($)：&quot;&lt;&lt;g&lt;&lt;endl;
	cout&lt;&lt;&quot;晶坷垃(G)：&quot;&lt;&lt;jkl&lt;&lt;endl;
	cout&lt;&lt;&quot;我方人数：&quot;&lt;&lt;o2+jde&lt;&lt;endl;
	cout&lt;&lt;&quot;敌方人数：&quot;&lt;&lt;e2+jd&lt;&lt;endl;
	cout&lt;&lt;&quot;我方血量：&quot;&lt;&lt;o1&lt;&lt;endl;
	cout&lt;&lt;&quot;敌方血量：&quot;&lt;&lt;e1&lt;&lt;endl;
	if(beta) cout&lt;&lt;&quot;主塔级别：&quot;&lt;&lt;Lv&lt;&lt;endl;
	if(ccc=='3') cout&lt;&lt;&quot;已生存天数：&quot;&lt;&lt;iii&lt;&lt;endl;
	if(zx!=0) cout&lt;&lt;&quot;已处于诈降状态&quot;&lt;&lt;endl;
	return ;
}
void bg();
void aa(string sssss){
	if(e1&lt;1000) bg();
	if(ssss==&quot;16391639&quot;){
		g=50000;
		e1=1000000;
		hd=10;
		o1=5000;
	}
	if(ssss!=&quot;test&quot;&amp;&amp;ssss!=&quot;16391639&quot;){
		cout&lt;&lt;&quot;在千年以前，有一群人类被感染成了异种\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;它们变得与常人不同,拥有更强大的力量与更强大的身体\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;正常人类带着排斥接受着它们\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;那次人类使出了全力对抗异种\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;双方死伤惨重,人类花了200年才恢复过来\n&quot;;
		cout&lt;&lt;&quot;而人类异种从此销声匿迹\n&quot;;
		Sleep(2000);
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;但现在，他们卷土重来了！！！&quot;;
		Sleep(2000);
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？&quot;;
		Sleep(2000);
	}
	while(true){
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;请选择模式\n&quot;;
		cout&lt;&lt;&quot;1 default:最后堡垒\n&quot;;
		cout&lt;&lt;&quot;2 beta:失落城邦\n&quot;;
		ch=getch();
		system(&quot;cls&quot;);
		if(ch=='1'){
			if(MessageBox(NULL,&quot;你真的要进入default模式吗？&quot;,&quot;提示&quot;,MB_YESNO)==IDYES){
				cout&lt;&lt;&quot;这是人类最后的希望...\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;你将坚守最后的城池，保卫身后那颗普蓝色的定界石\n&quot;;
				Sleep(3500);
				cout&lt;&lt;&quot;这个阶段，史称\n&quot;;
				Sleep(1000);
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;最后堡垒!!!\n&quot;;
				break;
			}
		}
		else if(ch=='2'){
			if(MessageBox(NULL,&quot;你真的要进入beta模式吗？&quot;,&quot;提示&quot;,MB_YESNO)==IDYES){
				cout&lt;&lt;&quot;人类从曾经摔倒的地方重新站起\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;我们即将迎来第一场反击战!\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;目光灼灼地望向前方，那曾是我们的家园\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;这个阶段，史称\n&quot;;
				Sleep(2000);
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;失落城邦!!!\n&quot;;
				beta=true;
				break;
			}
		}
	}
	Sleep(2000);
	while(true){
		system(&quot;cls&quot;);
		if(!beta){
			cout&lt;&lt;&quot;战争 7.5.7\n&quot;;
			cout&lt;&lt;&quot;1 攻略\n&quot;;
			cout&lt;&lt;&quot;2 各世界属性\n&quot;;
			cout&lt;&lt;&quot;3 造物主模式\n&quot;;
			cout&lt;&lt;&quot;4 生存模式\n&quot;;
			cout&lt;&lt;&quot;5 衰竭模式\n&quot;;
			cout&lt;&lt;&quot;6 普通模式\n&quot;;
		}else{
			cout&lt;&lt;&quot;战争-beta 1.2.1\n&quot;;//beta模式版本号-6,-3,-6
			cout&lt;&lt;&quot;开始\n&quot;;
		}
		ch=getch();
		if(beta){
			system(&quot;cls&quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		if(!beta&amp;&amp;ch=='1'){
			cout&lt;&lt;char(7);
			cout&lt;&lt;&quot;首先，你可以一直按0大约10次，攒到大约200\n&quot;;
			cout&lt;&lt;&quot;然后，你可以建一层护盾和一个哨兵塔，用来进攻\n&quot;;
			cout&lt;&lt;&quot;接着，继续攒钱，建高射炮来防御坦克及飞机\n&quot;;
			cout&lt;&lt;&quot;最后，只需要在建筑有破损时重建就行了\n&quot;;
			getch();
		}
		else if(!beta&amp;&amp;ch=='2'){
			system(&quot;cls&quot;);
			cout&lt;&lt;&quot;造物主模式初始资源很多\n&quot;;
			cout&lt;&lt;&quot;生存模式资源中等\n&quot;;
			cout&lt;&lt;&quot;衰竭模式资源匮乏，每回合我方扣固定的100血量\n&quot;;
			Sleep(5000);
		}
		else if(!beta&amp;&amp;ch=='3'){
			system(&quot;cls&quot;);
			g=10000;
			jkl=500;
			e1=100000;
			hd=10;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;&amp;ch=='4'){
			system(&quot;cls&quot;);
			g=1000;
			e1=100000;
			hd=5;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;&amp;ch=='5'){
			system(&quot;cls&quot;);
			e=100;
			break;
		}
		else if(!beta&amp;&amp;ch=='@'){
			cout&lt;&lt;char(7)&lt;&lt;char(7)&lt;&lt;char(7)&lt;&lt;char(7);
			cout&lt;&lt;&quot;此版本已上传至永远的CC的博客\n&quot;;
			Sleep(1500);
		}
		else if(!beta&amp;&amp;ch=='6'){
			system(&quot;cls&quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		else cout&lt;&lt;&quot;不要乱输\n&quot;,Sleep(1500);
	}
	system(&quot;cls&quot;);
	if(ssss!=&quot;test&quot;){
		cout&lt;&lt;&quot;加载中...&quot;;
		cout&lt;&lt;endl;
		srand(time(0));
		xx=rand()%int(rand?12:11);
		switch(xx){
			case 0:cout&lt;&lt;&quot;高射炮不仅可以打飞机，把它压下来也可以打地面敌人！&quot;;break;
			case 1:cout&lt;&lt;&quot;迫击炮不仅可以打小兵，还能打敌方基地！&quot;;break;
			case 2:cout&lt;&lt;&quot;小兵打敌方基地的伤害十分可观。&quot;;break;
			case 3:cout&lt;&lt;&quot;导弹可以直接打对方的基地！&quot;;break;
			case 4:cout&lt;&lt;&quot;千万别让小兵接近你的基地，你的建筑十分危险！&quot;;break;
			case 5:cout&lt;&lt;&quot;激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！&quot;;break;
			case 6:cout&lt;&lt;&quot;护盾可以抵挡敌方的一次远程进攻哦！&quot;;break;
			case 7:cout&lt;&lt;&quot;克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用&quot;;break;
			case 8:cout&lt;&lt;&quot;岩石地雷可以在五回合后炸死敌方所有小兵哦！&quot;;break;
			case 9:cout&lt;&lt;&quot;晶坷垃是一种新型货币，不可与金币互换。&quot;;break;
			case 10:cout&lt;&lt;&quot;头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。&quot;;break;
			case 11:cout&lt;&lt;&quot;歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。&quot;;break;
		}
		cout&lt;&lt;'\n';
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=14;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(2000,1000);
		cout&lt;&lt;&quot; 100%&quot;;
		Sleep(1500);
		system(&quot;cls&quot;);
	}else
	{
		cout&lt;&lt;&quot;ji guang pao (ji fang):&quot;;
		cin&gt;&gt;jg;
		cout&lt;&lt;&quot;di fang gong ji li:&quot;;
		cin&gt;&gt;e;
	}
	//system(&quot;taskkill -f -im f_bgm.exe&quot;);
	//system(&quot;start bgm.exe&quot;);
	system(&quot;cls&quot;);
	while(o1&gt;0&amp;&amp;e1&gt;0&amp;&amp;(sssss==&quot;16391639&quot;||ch=='3'||ch=='2'||g&lt;=100000&amp;&amp;o1&lt;=300000)){
		int ttt=o2;
		int fff=e2;
		o1-=e;
		int last_hp=o1;
		int last_hpe=e1;
		jkl++;
		jkl+=jkl_kc;
		water++;
		xs(ch);
		d=' ';
		srand(time(NULL));
		for(i=1;i&lt;=1+int(beta);i++){
			l=rand()%30+1;
			if(zx!=0){
				zx--;
				l=12;
			}
			if(l&gt;=0&amp;&amp;l&lt;=1){
				sl=rand()%20+1;
				cout&lt;&lt;sl&lt;&lt;&quot;个小兵出现了\n&quot;;
				e2+=sl;
			}
			if(l&gt;=2&amp;&amp;l&lt;=3){
				if(hd==0){
					o1-=100;
					cout&lt;&lt;&quot;一颗导弹在空中画出了一道完美的弧线\n&quot;;
				}
				else{
					hd--;
					cout&lt;&lt;&quot;一颗导弹炸毁了一层护盾\n&quot;;
				}
			}
			if(l&gt;=4&amp;&amp;l&lt;=5){
				if(o2==0)
					if(tk!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&quot;;
						tk--;
					}
					else if(hd!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁了一层护盾\n&quot;;
						hd--;
					}
					else{
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&quot;;
						o1-=80;
					}
				else{
					o2-=40;
					if(o2&lt;0) o2=0;
					cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&quot;;
				}
			}
			if(l&gt;=6&amp;&amp;l&lt;=7){
				cout&lt;&lt;&quot;一块巨石忽忽悠悠地飞来\n&quot;;
				o2-=35;
				if(o2&lt;0) o2=0;
			}
			if(l&gt;=8&amp;&amp;l&lt;=9){
				cout&lt;&lt;&quot;一颗狙击枪子弹射来，&quot;;
				if(pj!=0){
					cout&lt;&lt;&quot;一门迫击炮炸了\n&quot;;
					pj--;
				}
				else if(jg!=0){
					cout&lt;&lt;&quot;一门激光炮炸了\n&quot;;
					jg--;
				}
				else if(ts!=0){
					cout&lt;&lt;&quot;一门投石机炸了\n&quot;;
					ts--;
				}
				else if(bt!=0){
					cout&lt;&lt;&quot;一座哨兵塔炸了\n&quot;;
					bt--;
				}
				else if(hd!=0){
					cout&lt;&lt;&quot;一层护盾炸了\n&quot;;
					hd--;
				}
				else{
					cout&lt;&lt;&quot;扣血150点\n&quot;;
					o1-=150;
				}
			}
			if(l&gt;=10&amp;&amp;l&lt;=10){
				srand(time(NULL));
				sl=rand()%3+1;
				if(sl==3) sl=2;
				else sl=1;
				cout&lt;&lt;sl&lt;&lt;&quot;辆坦克轰然出现\n&quot;;
				tke+=sl;
			}
			if(l&gt;=11&amp;&amp;l&lt;=11){
				if(beta){
					cout&lt;&lt;&quot;咻！一架歼击机穿过云层\n&quot;;
					jjje++;
				}else cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
			}
			if(l&gt;=13&amp;&amp;l&lt;=13){
				cout&lt;&lt;&quot;敌方建造了一个护盾\n&quot;;
				hde++;
			}
			if(l&gt;=14&amp;&amp;l&lt;=15){
				if(fj!=0){
					cout&lt;&lt;&quot;高射炮向天空扫去，一架飞机掉了下来\n&quot;;
					fj--;
				}
				else{
					if(tk!=0){
						cout&lt;&lt;&quot;高射炮向地面扫去，炸毁一辆坦克\n&quot;;
						tk--;
					}
					else{
						if(o2!=0){
							cout&lt;&lt;&quot;高射炮向地面扫去，炸死一个小兵\n&quot;;
							o2--;
						}
						else cout&lt;&lt;&quot;高射炮没有目标\n&quot;;
					}
				}
			}
			if(l&gt;=16&amp;&amp;l&lt;=16){
				cout&lt;&lt;&quot;一架飞机出现了\n&quot;;
				fje++;
			}
			if(l&gt;=17&amp;&amp;l&lt;=18){
				cout&lt;&lt;&quot;瘟疫发生了\n&quot;;
				o2/=2;
			}
			if(l&gt;=19&amp;&amp;l&lt;=19){
				if(fj&gt;=2){
					cout&lt;&lt;&quot;一束激光射向天空，两架飞机掉了下来\n&quot;;
					fj-=2;
				}
				else{
					if(fj==1){
						cout&lt;&lt;&quot;一束激光射向天空，一架飞机掉了下来\n&quot;;
						fj--;
					}
					else if(tk!=0&amp;&amp;o2!=0){
						cout&lt;&lt;&quot;一束激光平射而来，击毁了&quot;&lt;&lt;min(3,tk)&lt;&lt;&quot;辆坦克，炸死&quot;&lt;&lt;min(20,o2)&lt;&lt;&quot;个小兵\n&quot;;
						tk-=min(3,tk);
						o2-=min(20,o2);
					}
					else{
						if(tk!=0){
							cout&lt;&lt;&quot;一束激光平射而来，击毁了&quot;&lt;&lt;min(3,tk)&lt;&lt;&quot;辆坦克\n&quot;;
							tk-=min(3,tk);
						}
						else{
							if(o2!=0){
								cout&lt;&lt;&quot;一束激光平射而来，炸死&quot;&lt;&lt;min(20,o2)&lt;&lt;&quot;个小兵\n&quot;;
								o2-=min(20,o2);
							}
							else if(hd!=0){
								cout&lt;&lt;&quot;一束激光平射而来，一层护盾炸了\n&quot;;
								hd--;
							}
							else{
								cout&lt;&lt;&quot;一束激光向你方平射而来\n&quot;;
								o1-=100;
							}
						}
					}
				}
			}
			if(l&lt;=20&amp;&amp;l&gt;=20){
				cout&lt;&lt;&quot;对方使用了神秘的法术，小兵数量变成了两倍\n&quot;;
				e2*=2;
			}
			if(l&lt;=21&amp;&amp;l&gt;=21){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
				jde++;
			}
			if(l&gt;=12&amp;&amp;l&lt;=12||l&gt;=22&amp;&amp;l&lt;=23||l&gt;=28&amp;&amp;l&lt;=30){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
			}
			if(l&gt;=24&amp;&amp;l&lt;=25){
				cout&lt;&lt;&quot;敌方建造了一个屏障\n&quot;;
				pze++;
			}
			if(l&gt;=26&amp;&amp;l&lt;=26){
				cout&lt;&lt;&quot;敌方建造了一个量子屏障\n&quot;;
				lzpze++;
			}
			if(l&gt;=27&amp;&amp;l&lt;=27){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
				dle++;
			}
			if(i==1) Sleep(2000);
		}
		dd=rand()%(beta?40:30)+1+jk*5;
		cout&lt;&lt;&quot;你得到了&quot;&lt;&lt;dd&lt;&lt;&quot;个金币\n&quot;;
		g+=dd;
		Sleep(2000);
		system(&quot;cls&quot;);
		while(d!='0'){
			xs(ch);
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;1   派出小兵 3$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             2   导弹 50$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;3   迫击炮 120$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             4   投石机 100$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;5   坦克 60$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             6   哨兵塔 100$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;7   高射炮 120$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             8   飞机 80$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;9   瘟疫 50$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             a   激光炮 180$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;b   护盾 80$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             c   克隆法术 80$/1&quot;;
			if(ch=='3') cout&lt;&lt;&quot;禁用\n&quot;;
			else cout&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;d   金矿开采机 50$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             e   间谍 80$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;f   诈降书 150$/1&quot;;
			if(zx!=0) cout&lt;&lt;&quot;禁用&quot;;
			else cout&lt;&lt;&quot;&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             g   屏障 2$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;h   量子屏障 10$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             i   岩石地雷 50$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;j   晶坷垃开采器 5G/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;            k   头铁少年 5G/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;l   钻地少年 5G/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             m   回血药水(回250) 10G+20$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;n   回血器(一次回50) 30G+60$/1&quot;&lt;&lt;&quot;\n&quot;;
			if(beta) cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;o   歼击机 120$+25G/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;p   打怪(实在不行去刷)&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;q   查看注释&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;r   开宝箱&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;s   查看成就&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;t   查看如何获得成就&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;u   抽奖&quot;&lt;&lt;endl;
			if(beta) cout&lt;&lt;&quot;*   升级主塔 100$+20G/1\n&quot;;
			cout&lt;&lt;&quot;\\   关闭\n&quot;;
			cout&lt;&lt;&quot;#   礼包码(hehe为官方礼包码)\n&quot;;
			cout&lt;&lt;&quot;0   继续&quot;;
			d=getch();
			if(d=='u'){
				cj();
			}
			if(d=='t'){
				system(&quot;cls&quot;);
				printf(&quot;买到终极宝箱（终极奥义）\n&quot;);
				printf(&quot;买宝箱20次  （奉献精神）\n&quot;);
				printf(&quot;杀死20个怪  （怪物猎人）\n&quot;);
				printf(&quot;买回血器5个 （回血大师）\n&quot;);
				printf(&quot;打死十级怪物（打怪大师）\n&quot;);
				Sleep(5000);
			}
			if(d=='s'){
				system(&quot;cls&quot;);
				if(zjay) printf(&quot;终极奥义\n&quot;);
				if(fxjs) printf(&quot;奉献精神\n&quot;);
				if(gwlr) printf(&quot;怪物猎人\n&quot;);
				if(hxds) printf(&quot;回血大师\n&quot;);
				if(dgds) printf(&quot;打怪大师\n&quot;);
				Sleep(5000);
			}
			if(d=='r'){
				kaibx();
			}
			if(d=='q'){
				system(&quot;cls&quot;);
				printf(&quot;因打怪，宝箱模板没有时间了，所以做得简陋一点\n&quot;);
				printf(&quot;下个版本升级的打怪\n&quot;);
				Sleep(5000);
			}
			if(d=='p'){
				bdaguai();
			}
			if(d=='#'){
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;请输入礼包码形如 *** 及你名字的缩写的小写形式\n&quot;;
				cout&lt;&lt;&quot;请输入:&quot;;
				string str;
				cin&gt;&gt;str;
				if(str==ssss)
				  g+=100,jkl+=100,e1+=100;
				cout&lt;&lt;&quot;正在处理...&quot;;
				Sleep(1500);
				system(&quot;cls&quot;);
				continue;
			}
			if(d=='\\'){
				system(&quot;cls&quot;);
				return;
			}
			if(beta&amp;&amp;d=='*'){
				if(g&gt;=100&amp;&amp;jkl&gt;=20){
					g-=100;
					jkl-=20;
					Lv++;
					o1_max+=500;
					o1+=500;
					lzpz+=10;
				}
			}
			if(d=='1'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*3&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				o2+=s;
				g-=s*3;
				system(&quot;cls&quot;);
			}
			if(d=='2'){
				if(g&gt;=50){
					g-=50;
					if(hde!=0){
						e1-=100;
					}
					else{
						hde--;
					}
				}
			}
			if(d=='3'){
				if(g&gt;=120){
					g-=120;
					pj++;
				}
			}
			if(d=='4'){
				if(g&gt;=100){
					g-=100;
					ts++;
				}
			}
			if(d=='5'){
				if(g&gt;=60){
					g-=60;
					tk++;
				}
			}
			if(d=='6'){
				if(g&gt;=100){
					g-=100;
					bt++;
				}
			}
			if(d=='7'){
				if(g&gt;=120){
					g-=120;
					gs++;
				}
			}
			if(d=='8'){
				if(g&gt;=80){
					g-=80;
					fj++;
				}
			}
			if(d=='9'){
				if(g&gt;=50){
					g-=50;
					e2/=2;
				}
			}
			if(d=='a'){
				if(g&gt;=180){
					g-=180;
					jg++;
				}
			}
			if(d=='b'){
				if(g&gt;=80){
					g-=80;
					hd++;
				}
			}
			if(d=='c'){
				if(g&gt;=80&amp;&amp;ch!='3'){
					g-=80;
					system(&quot;cls&quot;);
					cout&lt;&lt;&quot;一抹神秘的光辉映在天空中，小兵变成了原来的两倍\n&quot;;
					Sleep(2500);
					o2*=2;
				}
			}
			if(d=='d'){
				if(g&gt;=50){
					g-=50;
					jk++;
				}
			}
			if(d=='e'){
				if(g&gt;=80){
					g-=80;
					jd++;
				}
			}
			if(d=='f'){
				if(g&gt;=150&amp;&amp;zx==0){
					g-=150;
					zx+=5;
				}
			}
			if(d=='g'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*2&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				pz+=s;
				g-=s*2;
				system(&quot;cls&quot;);
			}
			if(d=='h'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*10&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				lzpz+=s;
				g-=s*10;
				system(&quot;cls&quot;);
			}
			if(d=='i'){
				if(g&gt;=50){
					g-=50;
					dl+=5;
				}
			}
			if(d=='j'){
				if(jkl&gt;=5){
					jkl-=5;
					jkl_kc++;
				}
			}
			if(d=='k'){
				if(jkl&gt;=5){
					jkl-=5;
					tt++;
				}
			}
			if(d=='l'){
				if(jkl&gt;=5){
					jkl-=5;
					zd++;
				}
			}
			if(d=='m'){
				if(jkl&gt;=10&amp;&amp;g&gt;=20){
					jkl-=10;
					g-=20;
					o1=min(o1_max,o1+250);
				}
			}
			if(d=='n'){
				if(jkl&gt;=30&amp;&amp;g&gt;=60){
					jkl-=30;
					g-=60;
					reblood++;
					hxcs++;
					if(hxcs&gt;=5&amp;&amp;hxds!=1){
						hxds=1;
						system(&quot;cls&quot;);
						printf(&quot;恭喜你取得了回血大师的成就！！！\n&quot;);
						Sleep(5000);
						printf(&quot;奖励10晶坷垃,100金币&quot;);
						g+=100;
						jkl+=10;
						Sleep(5000);
					}
				}
			}
			if(d=='o'){
				if(g&gt;=120&amp;&amp;jkl&gt;=25){
					g-=120;
					jkl-=25;
					jjj++;
				}
			}
			system(&quot;cls&quot;);
		}
		if(dl!=0){
			if(dl%5!=0)
			  dl-=(dl/5+1);else
			  dl-=dl/5;
			if(dl%5==0){
				cout&lt;&lt;&quot;一声惊天巨响，敌方小兵化为骨灰\n&quot;;
				e2=0;
			}
		}
		if(dle!=0){
			if(dle%5!=0)
			  dle-=(dle/5+1);else
			  dle-=dle/5;
			if(dle%5==0){
				cout&lt;&lt;&quot;一声惊天巨响，我方小兵化为骨灰\n&quot;;
				o2=0;
			}
		}
		if(jd!=0){
			if(e2!=0){
				cout&lt;&lt;&quot;我方间谍使敌方&quot;&lt;&lt;min(jd,e2)&lt;&lt;&quot;个小兵叛变了\n&quot;;
				e2-=min(jd,e2);
				o2+=min(jd,e2);
			}
			else{
				cout&lt;&lt;&quot;我方间谍被发现！\n&quot;;
				jd=0;
			}
		}
		if(jde!=0){
			if(o2!=0){
				o2-=min(jde,o2);
				e2+=min(jde,o2);
			}
			else{
				cout&lt;&lt;&quot;敌方间谍被发现！\n&quot;;
				jde=0;
			}
		}
		if(tt!=0){
			if(hde!=0){
				hde-=min(min(tt,hde),jkl);
				jkl-=min(min(tt,hde),jkl);
			}
			if(hde&lt;=0) hde=0;
		}
		if(zd!=0){
			if(e2!=0){
				e2-=min(min(e2/10,zd),jkl);
				jkl-=min(min(e2/10,zd),jkl);
			}
			if(e2&lt;=0) e2=0;
		}
		for(i=1;i&lt;=pj;i++)
			if(e2==0)
				if(tke!=0){
					cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&quot;;
					tke--;
				}
				else{
					if(hde!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，击毁一层护盾\n&quot;;
						hde--;
					}
					else{
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向敌方飞去\n&quot;;
						e1-=80;
					}
				}
			else{
				if(e2&gt;=40){
					g+=80;
					e2-=40;
				}
				else{
					g+=e2*2;
					e2=0;
				}
				if(e2&lt;0) e2=0;
				cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&quot;;
			}
		for(i=1;i&lt;=ts;i++){
			if(e2&gt;=35){
				e2-=35;
				g+=70;
			}
			else{
				g+=e2*2;
				e2=0;
			}
			cout&lt;&lt;&quot;一块巨石忽忽悠悠地飞去\n&quot;;
		}
		for(i=1;i&lt;=bt;i++){
			cout&lt;&lt;&quot;5个小兵慢悠悠地从哨兵塔里走出来\n&quot;;
			o2+=5;
		}
		for(i=1;i&lt;=gs;i++){
			if(fje!=0){
				cout&lt;&lt;&quot;高射炮向天空扫去，一架飞机掉了下来\n&quot;;
				fje--;
			}
			else{
				if(tke!=0){
					cout&lt;&lt;&quot;高射炮向地面扫去，炸毁一辆坦克\n&quot;;
					tke--;
				}
				else{
					if(e2!=0){
						cout&lt;&lt;&quot;高射炮向地面扫去，炸死一个小兵\n&quot;;
						e2--;
					}
					else cout&lt;&lt;&quot;高射炮没有目标\n&quot;;
				}
			}
		}
		for(i=1;i&lt;=jg;i++)
			if(fje&gt;=2){
				cout&lt;&lt;&quot;一束激光射向天空，两架飞机掉了下来\n&quot;;
				fje-=2;
			}
			else{
				if(fje==1){
					cout&lt;&lt;&quot;一束激光射向天空，一架飞机掉了下来\n&quot;;
					fje--;
				}
				else if(tke!=0&amp;&amp;e2!=0){
					cout&lt;&lt;&quot;一束激光平射出去，击毁了&quot;&lt;&lt;min(3,tke)&lt;&lt;&quot;辆坦克，炸死&quot;&lt;&lt;min(15,e2)&lt;&lt;&quot;个小兵\n&quot;;
					tke-=min(3,tke);
					e2-=min(15,e2);
				}
				else{
					if(tke!=0){
						cout&lt;&lt;&quot;一束激光平射出去，击毁了&quot;&lt;&lt;min(3,tke)&lt;&lt;&quot;辆坦克\n&quot;;
						tke-=min(3,tke);
					}
					else{
						if(e2!=0){
							cout&lt;&lt;&quot;一束激光平射出去，炸死&quot;&lt;&lt;min(15,e2)&lt;&lt;&quot;个小兵\n&quot;;
							e2-=min(15,e2);
						}
						else{
							if(hde!=0){
								cout&lt;&lt;&quot;一束激光平射出去，击毁一层护盾\n&quot;;
								hde--;
							}
							else{
								cout&lt;&lt;&quot;一束激光向敌方平射出去\n&quot;;
								e1-=150;
							}

						}
					}
				}
			}
		if(fj!=0&amp;&amp;fje!=0){
			fk=fj&lt;fje?fj:fje;
			fj-=fk;fje-=fk;
			cout&lt;&lt;&quot;双方都有&quot;&lt;&lt;fk&lt;&lt;&quot;架飞机从空中落下来了\n&quot;;
		}
		for(i=1;i&lt;=fj;i++){
			if(hde!=0){
				cout&lt;&lt;&quot;我方飞机击毁一层护盾\n&quot;;
				hde--;
			}
			else{
				cout&lt;&lt;&quot;我方飞机俯冲轰炸！\n&quot;;
				e1-=150;
			}
		}
		for(i=1;i&lt;=fje;i++){
			if(hd!=0){
				cout&lt;&lt;&quot;敌方飞机击毁我方一层护盾\n&quot;;
				hd--;
			}
			else{
				cout&lt;&lt;&quot;敌方飞机俯冲轰炸！\n&quot;;
				o1-=150;
			}
		}
		if(jjj!=0&amp;&amp;jjje!=0){
			fk=jjj&lt;jjje?jjj:jjje;
			jjj-=fk;jjje-=fk;
			cout&lt;&lt;&quot;双方都有&quot;&lt;&lt;fk&lt;&lt;&quot;架歼击机从空中落下来了\n&quot;;
		}
		for(i=1;i&lt;=jjj;i++){
			if(hde!=0){
				cout&lt;&lt;&quot;我方歼击机击毁一层护盾\n&quot;;
				hde--;
			}
			else{
				cout&lt;&lt;&quot;我方歼击机俯冲轰炸！\n&quot;;
				e1-=200;
			}
		}
		for(i=1;i&lt;=jjje;i++){
			if(hd!=0){
				cout&lt;&lt;&quot;敌方歼击机击毁我方一层护盾\n&quot;;
				hd--;
			}
			else{
				cout&lt;&lt;&quot;敌方歼击机俯冲轰炸！\n&quot;;
				o1-=200;
			}
		}
		if(tk!=0&amp;&amp;tke!=0){
			tkk=tk&lt;tke?tk:tke;
			cout&lt;&lt;&quot;坦克开炮了，双方都有&quot;&lt;&lt;tkk&lt;&lt;&quot;门坦克损毁了\n&quot;;
			tk-=tkk;tke-=tkk;
		}
		if(o2!=0&amp;&amp;tke*20&gt;o2){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;o2&lt;&lt;&quot;个小兵死去了\n&quot;;
			if(o2/20!=0)
				cout&lt;&lt;o2/20&lt;&lt;&quot;门坦克损毁了\n&quot;;
			o2=0;tke-=o2/20;
		}
		if(tke!=0&amp;&amp;o2&gt;=tke*20){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;tke*20&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tke*60;
			cout&lt;&lt;tke&lt;&lt;&quot;门坦克损毁了\n&quot;;
			o2-=tke*20;tke=0;
		}
		if(o2!=0&amp;&amp;e2!=0)
			cout&lt;&lt;&quot;有小兵倒下去了\n&quot;;
		else cout&lt;&lt;&quot;没有小兵倒下\n&quot;;
		if(e2!=0&amp;&amp;tk*20&gt;e2){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;e2&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tk*60;
			if(e2/20!=0)
				cout&lt;&lt;e2/20&lt;&lt;&quot;门坦克损毁了\n&quot;;
			e2=0;tk-=e2/20;
		}
		if(tk!=0&amp;&amp;e2&gt;=tk*20){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;tk*20&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tk*60;
			cout&lt;&lt;tk&lt;&lt;&quot;门坦克损毁了\n&quot;;
			e2-=tk*20;tk=0;
		}
		if(ttt-o2&gt;50){
			o2-=(ttt-o2)/10;
			cout&lt;&lt;&quot;我方有&quot;&lt;&lt;(ttt-o2)/10&lt;&lt;&quot;个小兵逃走了&quot;;
		}
		if(fff-e2&gt;50){
			e2-=(fff-e2)/10;
			cout&lt;&lt;&quot;敌方有&quot;&lt;&lt;(fff-e2)/10&lt;&lt;&quot;个小兵逃走了&quot;;
		}
		if(o2&gt;e2){
			g+=e2*2;
			o2-=e2;
			e2=0;
		}
		else{
			g+=o2*2;
			e2-=o2;
			o2=0;
		}
		if(o2!=0){
			e1-=o2*5;
			cout&lt;&lt;&quot;我方小兵围殴敌方，扣血&quot;&lt;&lt;o2*5&lt;&lt;&quot;点\n&quot;;
		}
		if(tk!=0){
			e1-=tk*20;
			cout&lt;&lt;&quot;我方坦克围殴敌方，扣血&quot;&lt;&lt;tk*20&lt;&lt;&quot;点\n&quot;;
		}
		if(e2!=0){
			k=e2;
			if(pj*30&gt;k){
				if(k/30!=0)
					cout&lt;&lt;k/30&lt;&lt;&quot;门迫击炮损坏了\n&quot;;
				pj-=k/30;
			}
			else{
				if(pj!=0)
					cout&lt;&lt;pj&lt;&lt;&quot;门迫击炮损坏了\n&quot;;
				k-=pj*30;pj=0;
				if(ts*25&gt;k){
					if(k/25!=0)
						cout&lt;&lt;k/25&lt;&lt;&quot;门投石机损坏了\n&quot;;
					ts-=k/25;
				}
				else{
					if(ts!=0)
						cout&lt;&lt;ts&lt;&lt;&quot;门投石机损坏了\n&quot;;
					k-=ts*25;ts=0;
					if(jg*35&gt;k){
						if(k/35!=0)
							cout&lt;&lt;k/35&lt;&lt;&quot;架激光炮损坏了\n&quot;;
						jg-=k/35;
					}
					else{
						if(jg!=0)
							cout&lt;&lt;jg&lt;&lt;&quot;架激光炮损坏了\n&quot;;
						k-=jg*35;jg=0;
						if(bt*20&gt;k){
							if(k/20!=0)
								cout&lt;&lt;k/20&lt;&lt;&quot;座哨兵塔损坏了\n&quot;;
							bt-=k/20;
						}
						else{
							if(bt!=0)
								cout&lt;&lt;bt&lt;&lt;&quot;座哨兵塔损坏了\n&quot;;
							k-=bt*20;bt=0;
							if(k!=0){
								cout&lt;&lt;&quot;敌方小兵围殴我方，扣血&quot;&lt;&lt;k*5&lt;&lt;&quot;点\n&quot;;
								o1-=k*5;
							}
						}
					}
				}
			}
		}
		for(i=1;i&lt;=tke;i++){
			if(pj!=0){
				pj--;
				cout&lt;&lt;&quot;1门迫击炮损坏了\n&quot;;
			}
			else if(jg!=0){
				jg--;
				cout&lt;&lt;&quot;1架激光炮损坏了\n&quot;;
			}
			else if(ts!=0){
				ts--;
				cout&lt;&lt;&quot;1门投石机损坏了\n&quot;;
			}
			else if(bt!=0){
				bt--;
				cout&lt;&lt;&quot;1座哨兵塔损坏了\n&quot;;
			}
			else{
				o1-=(tke-i+1)*100;
				cout&lt;&lt;&quot;敌方坦克围殴我方，扣血&quot;&lt;&lt;(tke-i+1)*100&lt;&lt;&quot;点\n&quot;;
				i=tke;
			}
		}
		if(o1&lt;last_hp) o1+=min(lzpz,last_hp-o1);
		if(o1&lt;last_hp){
			o1+=min(pz,last_hp-o1);
			pz-=min(pz,last_hp-o1);
		}
		if(e1&lt;last_hpe) e1+=min(lzpze,last_hpe-e1);
		if(e1&lt;last_hpe){
			e1+=min(pze,last_hpe-e1);
			pze-=min(pze,last_hpe-e1);
		}
		cout&lt;&lt;&quot;咕嘟嘟,+&quot;&lt;&lt;reblood*50&lt;&lt;&quot;血\n&quot;;
		o1=min(o1_max,o1+reblood*50);
		Sleep(3000);
		system(&quot;cls&quot;);
		if(ch=='3') ++iii;
	}
	if(g&gt;10000||o1&gt;10000) bg();
	if(o1&lt;=0){
		if(e1&gt;500&amp;&amp;e1&lt;1500) cout&lt;&lt;&quot;城池被攻破，人类的最后一道防线破碎，人类沦为了宇宙中的一片尘埃。\n&quot;;
		if(e1&gt;=1500) cout&lt;&lt;&quot;你已经很努力了，但敌方太强，你无法抗衡\n人类不堪的淹没在了历史的长河中。\n&quot;;
		if(e1&lt;=500) cout&lt;&lt;&quot;你的各个方面都很强，但在最后无法力挽狂澜，才使人类文明灭亡。\n&quot;;
	}
	else{
		if(o1&gt;500&amp;&amp;o1&lt;1500) cout&lt;&lt;&quot;你靠自己的顽强决心守住了城池，救回了人类文明。\n&quot;;
		if(o1&lt;=500) cout&lt;&lt;&quot;你在最后的紧要关头击退了人类异种，挽救了人类文明。\n&quot;;
		if(o1&gt;=1500) cout&lt;&lt;&quot;你以自己的高超指挥能力击退了人类异种，拯救了整个人类！！！\n\n&quot;;
	}
	Sleep(3000);
	system(&quot;cls&quot;);
	if(ssss!=&quot;16391639&quot;){
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;若有bug,加入需求及新想法,请发表\n&quot;;
		cout&lt;&lt;&quot;goodbye&quot;&lt;&lt;endl;
		Sleep(2500);
		return;
	}
	//system(&quot;taskkill -f -im bgm.exe&quot;);
	//system(&quot;cls&quot;);
	//system(&quot;start second.exe&quot;);
	//Sleep(5000);
	//system(&quot;start third.exe&quot;);
	//system(&quot;pause&quot;);
	return;
}
void bg(){
	system(&quot;cls&quot;);
	cout&lt;&lt;&quot;小朋友想走不正当途径是不好的\n&quot;;
	Sleep(3000);
	xs(ch);
	for(i=1;i&lt;=10000;i++)
		 cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&quot;;
	cout&lt;&lt;&quot;你死了！&quot;;
}
int main(){
	//system(&quot;start f_bgm.exe&quot;);
	//system(&quot;start first.exe&quot;);
	//system(&quot;cls&quot;);
	std::srand(time(0));
	printf(&quot;加载中...\n&quot;);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=14;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(2000,1000);
	cout&lt;&lt;&quot; 100%&quot;;
	Sleep(1500);
	system(&quot;cls&quot;);
	cout&lt;&lt;&quot;黑_白(永远的CC) 段建泽出品\n&quot;;
	cout&lt;&lt;&quot;请输入姓名\n&quot;;
	cout&lt;&lt;&quot;格式为***，前后没有空格，全部为小写\n&quot;;
	cin&gt;&gt;ssss;
	system(&quot;cls&quot;),aa(ssss);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快读快写是什么？怎么写？可以用来卡常吗？]]></title>
        <id>https://yydcc-blog.github.io/post/kuai-du-kuai-xie-shi-shi-me-zen-me-xie-ke-yi-yong-lai-qia-chang-ma/</id>
        <link href="https://yydcc-blog.github.io/post/kuai-du-kuai-xie-shi-shi-me-zen-me-xie-ke-yi-yong-lai-qia-chang-ma/">
        </link>
        <updated>2022-01-28T07:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-0前言">Part 0：前言</h1>
<p>突发奇想，来介绍快读快写。</p>
<p>希望大家喜欢！😉</p>
<h1 id="part-1快读快写是什么">Part 1：快读快写是什么？</h1>
<p>因为<code>getchar()</code>和<code>putchar()</code>很快，所以我们可以利用这个把输入输出的速度提到很快。</p>
<h1 id="part-2怎么写">Part 2：怎么写？</h1>
<h2 id="part-21快读">Part 2.1：快读</h2>
<h3 id="写法">写法：</h3>
<p>首先定义函数<code>int read()</code></p>
<p>既然是读入整数，那么就要把多余的空格和负数考虑到：</p>
<pre><code class="language-cpp">int f=1;
char ch=getchar();
while(ch&lt;'0'||ch&gt;'9'){
	if(ch=='-')
	f=-1;
	ch=getchar();
}
</code></pre>
<p>然后边输入边加在一个变量上：</p>
<pre><code class="language-cpp">int s=0;
while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
	s=s*10+ch-'0';
	ch=getchar();
}
</code></pre>
<p>这里还不够快，把<code>s*10</code>改成位运算：<code>(s&lt;&lt;1+s&lt;&lt;3)</code>。</p>
<p>最后输出（别忘把负数的情况考虑上）：<code>return s*f</code>。</p>
<p>完整代码：</p>
<pre><code class="language-cpp">int read(){
	int s=0,f=1;
	char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
		s=(s&lt;&lt;1+s&lt;&lt;3)+ch-'0';
		ch=getchar();
	}
	return s*f;
}
</code></pre>
<h3 id="解析">解析：</h3>
<ul>
<li>定义函数和变量。</li>
<li><code>while()</code>输入直到<code>-</code>或数字，记录负数的情况。</li>
<li><code>while()</code>边输入边累加。</li>
<li><code>return</code>返回值。</li>
</ul>
<h2 id="part-22快写">Part 2.2：快写</h2>
<p>递归写法，比较简单。</p>
<p>完整代码：</p>
<pre><code class="language-cpp">void write(int x){
    if(x&lt;0){
    	putchar('-');
		x=-x;
	}
    if(x&gt;9) 
		write(x/10);
    putchar(x%10+'0');
}
</code></pre>
<h1 id="part3可以用来卡常吗">Part3：可以用来卡常吗？</h1>
<p>可以。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用C++玩generals.io]]></title>
        <id>https://yydcc-blog.github.io/post/ru-he-yong-cwan-generalsio/</id>
        <link href="https://yydcc-blog.github.io/post/ru-he-yong-cwan-generalsio/">
        </link>
        <updated>2022-01-26T07:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>源自generals.io</p>
<p>大洋彼岸的服务器体验极差！</p>
<p>使用说明</p>
<p>整合了零人、单人、双人版</p>
<h1 id="单人版通用规则">单人版&amp;&amp;通用规则</h1>
<p>图片：https://www.picb.cc/image/tAJbks和https://www.picb.cc/image/tAJ7Nj</p>
<p>先输入0/1/2，代表游戏人数</p>
<p>然后要输入一个随机数种子（更新：长度可以任意），相同种子（相同编译器？）生成相同地图</p>
<p>地图：X为障碍，黑色背景的数为原有城市，红色为玩家的，蓝色为电脑的，城市和普通地面颜色不同</p>
<p>数字表示：数大于99时只显示最高位和一个字母 （e代表100，k代表1000，w代表10000），数大于99999就显示&quot;ju&quot; （巨）</p>
<p>在屏幕左下角可以看到光标所指的数的精确值（hp）</p>
<p>光标是一个小于号&quot;&lt;&quot;，用方向键控制光标</p>
<p>按下w/s/a/d时，光标的左边那个数（前提是自己的）会随光标移动</p>
<p>按下z，再按w/s/a/d，光标的左边那个数（前提是自己的）的一半会随光标移动</p>
<p>无法移动的情况：遇到障碍/下一个位置上的数不是自己的，且&gt;=自己的数-1</p>
<p>时间以回合（count）为单位，在屏幕左下角</p>
<p>移动光标不算回合，移动数字算，按到空格键视作放弃一回合</p>
<p>城市每回合+2，其余被占领的地面每10回合+1</p>
<p>屏幕左下角的&quot;army&quot;指一方数字和，&quot;land&quot;指一方占领的格子数</p>
<h1 id="零人版">零人版</h1>
<p>两个一样的bfs算法对打</p>
<p>只要观战就可以啦</p>
<p>可以按方向键移动光标，但不能移动任何数</p>
<p>按下空格键进入下一回合</p>
<p>如果想快点看到结果，按f键，之后无法移动光标</p>
<h1 id="双人版">双人版</h1>
<p>红方键盘：(z/x+) w/s/a/d，默认只移动光标，按z移一半<br>
数，按x移全部</p>
<p>蓝方键盘：(n/m+) 方向键，默认只移动光标，按n移一半数，按m移全部</p>
<p>任何一方按空格可以放弃一回合</p>
<p>游戏时间会很漫长</p>
<p>地图有概率出现“封城”，城市也可能分布不公平，换一个种<br>
子重启（继续碰运气）即可</p>
<p>当一方操作结束，光标会移到地图的左上角或右下角，（希望）能方便操作</p>
<p>结束条件：占领所有主塔（最开始的塔再【1】【1】或【n】【n】）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt; 
#include&lt;cstdio&gt; 
#include&lt;fstream&gt; 
#include&lt;algorithm&gt; 
#include&lt;cmath&gt; 
#include&lt;deque&gt; 
#include&lt;vector&gt; 
#include&lt;queue&gt; 
#include&lt;string&gt; 
#include&lt;cstring&gt; 
#include&lt;map&gt; 
#include&lt;stack&gt; 
#include&lt;set&gt; 
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;ctime&gt;
using namespace std;

const int cA=5;//red城市 
const int cB=3;//blue城市 
const int ca=4;//red地面 
const int cb=1;//blue地面 
const int cC=0;//black原有城市 
const int msize=16;//地图大小 
const int mount=16;//障碍数量 
const int grey=16;//城市数量 
const int pmain=2;//城市hp每回合增加量 
const int lcnt=10;//地面hp增加1所需回合 

char cMap[msize][msize];//大写字母表示城市，小写表示地面，Aa是红，Bb是蓝，C是白，X是障碍 
int hp[msize][msize];
int nCount,sx,sy;//回合累加，和光标的坐标 
bool bVis[msize][msize];//bfs
int dir[4][2]={1,0,-1,0,0,1,0,-1};//bfs

struct dRet//决策信息：位置为(x,y)的数移到(x+dx,y+dy) 
{
	int x;
	int y;
	int dx;
	int dy;
};

struct node//bfs 
{
	int x;
	int y;
	int step;
};

void vInit();//生成地图 
void vMove(int dx,int dy);//移动光标 
//以下5个函数，保证A=='A'||A=='B' 
void vMoveNum(int dx,int dy,char A);
void vMoveNum(int x,int y,int dx,int dy,char A);
void vDiv(int dx,int dy,char A);
void vDecide(char A);
dRet bfs(int x,int y,char A);
void vPlus();//每回合数值增加，计算army和land 
void vChange(int x,int y);//刷新屏幕上指定坐标的数 
void gotoxy(int x,int y);//移动输出的位置 
void color(int t,int b);//设置输出颜色，t为文字色，b为背景色 
void vMain0();
void vMain1();
void vMain2();
void vEnd();//判断游戏结束 

int main()
{
	int p; 
	cout&lt;&lt;&quot;player:&quot;&lt;&lt;endl;
	cin&gt;&gt;p;
	system(&quot;cls&quot;);
	if(p==0) vMain0();
	if(p==1) vMain1();
	if(p==2) vMain2();
	return 0;
}

void vMain0()
{
	int in;
	bool cur=true;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount&lt;&lt;endl;
		if(cur)
		{
			do
			{
				in=getch();
				if(in==224) 
				{
					in=getch();
					if(in==72) vMove(-1,0);
					if(in==80) vMove(1,0);
					if(in==75) vMove(0,-1);
					if(in==77) vMove(0,1);
				}
			}while(in!=' '&amp;&amp;in!='f');
			if(in=='f') cur=false;
		}
		vDecide('A');
		vDecide('B');
		vPlus();
	}
}

void vMain1()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount&lt;&lt;endl;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!='w'&amp;&amp;in!='s'&amp;&amp;in!='a'&amp;&amp;in!='d'&amp;&amp;in!='z'&amp;&amp;in!=' ');
		if(in=='w') vMoveNum(-1,0,'A');
		if(in=='s') vMoveNum(1,0,'A');
		if(in=='a') vMoveNum(0,-1,'A');
		if(in=='d') vMoveNum(0,1,'A');
		if(in=='z')
		{
			in=getch();
			if(in=='w') vDiv(-1,0,'A');
			if(in=='s') vDiv(1,0,'A');
			if(in=='a') vDiv(0,-1,'A');
			if(in=='d') vDiv(0,1,'A');
		}
		vDecide('B');
		vPlus();
	}
}

void vMain2()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount;
		vMove(-sx,-sy);
		gotoxy(msize+1,0);
		cout&lt;&lt;&quot;red &quot;;
		do
		{
			in=getch();
			if(in=='w') vMove(-1,0);
			if(in=='s') vMove(1,0);
			if(in=='a') vMove(0,-1);
			if(in=='d') vMove(0,1);
		}while(in!='x'&amp;&amp;in!='z'&amp;&amp;in!=' ');
		if(in=='x')
		{
			in=getch();
			if(in=='w') vMoveNum(-1,0,'A');
			if(in=='s') vMoveNum(1,0,'A');
			if(in=='a') vMoveNum(0,-1,'A');
			if(in=='d') vMoveNum(0,1,'A');
		}
		else if(in=='z')
		{
			in=getch();
			if(in=='w') vDiv(-1,0,'A');
			if(in=='s') vDiv(1,0,'A');
			if(in=='a') vDiv(0,-1,'A');
			if(in=='d') vDiv(0,1,'A');
		}
		vEnd();
		////////////////////////////////
		vMove(msize-1-sx,msize-1-sy);
		gotoxy(msize+1,0);
		color(15,0);
		cout&lt;&lt;&quot;blue&quot;;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!='n'&amp;&amp;in!='m'&amp;&amp;in!=' ');
		if(in=='m')
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMoveNum(-1,0,'B');
				if(in==80) vMoveNum(1,0,'B');
				if(in==75) vMoveNum(0,-1,'B');
				if(in==77) vMoveNum(0,1,'B');
			}
		}
		else if(in=='n')
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vDiv(-1,0,'B');
				if(in==80) vDiv(1,0,'B');
				if(in==75) vDiv(0,-1,'B');
				if(in==77) vDiv(0,1,'B');
			}
		}
		vPlus();
	}
}

void vInit()
{
	int i,j,x,y;
	string sSeed; 
	unsigned int sd=20190622;
	cout&lt;&lt;&quot;seed:&quot;&lt;&lt;endl;
	cin&gt;&gt;sSeed;
	system(&quot;cls&quot;);
	for(i=0;i&lt;sSeed.size();i++) sd=sd*233+sSeed[i];
	srand(sd);
	cMap[0][0]='A';
	hp[0][0]=pmain;
	vChange(0,0);
	cMap[msize-1][msize-1]='B';
	hp[msize-1][msize-1]=pmain;
	vChange(msize-1,msize-1);
	for(i=1;i&lt;=mount;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]='X';
			gotoxy(x,y*3);
			color(15,0);
			cout&lt;&lt;&quot; X&quot;;
		}
	}
	for(i=1;i&lt;=grey;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]='C';
			hp[x][y]=40+rand()%10;
			vChange(x,y);
		}
	}
	sx=sy=0;
	gotoxy(0,2);
	color(15,0);
	cout&lt;&lt;&quot;&lt;&quot;;
}

void vMove(int dx,int dy)
{
	color(15,0);
	dx+=sx;dy+=sy;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize)) return;
	gotoxy(sx,sy*3+2);
	cout&lt;&lt;&quot; &quot;;
	sx=dx;sy=dy;
	gotoxy(sx,sy*3+2);
	cout&lt;&lt;&quot;&lt;&quot;;
	gotoxy(msize+1,0);
	cout&lt;&lt;&quot;cMap=&quot;&lt;&lt;cMap[dx][dy]&lt;&lt;&quot;,hp=&quot;&lt;&lt;hp[dx][dy]&lt;&lt;&quot;            &quot;;
}

void vMoveNum(int x,int y,int dx,int dy,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	if(cMap[x][y]!=a&amp;&amp;cMap[x][y]!=A) return;
	dx+=x;dy+=y;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;cMap[dx][dy]!='X')) return;
	char &amp;cd=cMap[dx][dy];
	int &amp;hd=hp[dx][dy],&amp;hs=hp[x][y];
	if(cd!=a&amp;&amp;cd!=A&amp;&amp;hd&gt;=hs-1) return;
	if(cd==0)
	{
		cd=a;
		hd=hs-1;
	}
	else if(cd==A||cd==a)
	{
		hd+=hs-1;
	}
	else if(cd==B||cd==b)
	{
		if(B=='B') cd--;
		else cd++;
		hd=hs-1-hd;
	}
	else//'C'
	{
		cd=A;
		hd=hs-1-hd;
	}
	hs=1;
	vChange(dx,dy);
	vChange(x,y);
}

void vMoveNum(int dx,int dy,char A)
{
	vMoveNum(sx,sy,dx,dy,A);
	vMove(dx,dy);
}

void vDiv(int dx,int dy,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	if(cMap[sx][sy]!=a&amp;&amp;cMap[sx][sy]!=A) return;
	dx+=sx;dy+=sy;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;cMap[dx][dy]!='X')) return;
	char &amp;cd=cMap[dx][dy];
	int &amp;hd=hp[dx][dy],&amp;hs=hp[sx][sy],tmp=hs/2;
	if(tmp==0) return;
	if(cd!=a&amp;&amp;cd!=A&amp;&amp;hd&gt;=tmp-1) return;
	if(cd==0)
	{
		cd=a;
		hd=tmp;
	}
	else if(cd==A||cd==a)
	{
		hd+=tmp;
	}
	else if(cd==B||cd==b)
	{
		if(B=='B') cd--;
		else cd++;
		hd=tmp-hd;
	}
	else//'C'
	{
		cd=A;
		hd=tmp-hd;
	}
	hs-=tmp;
	vChange(dx,dy);
	vChange(sx,sy);
	vMove(dx-sx,dy-sy);
}

void vDecide(char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	int i,j,k,x,y,dx,dy;
	dRet tmp,res;
	bool bd=false,bm=false;
	for(i=(A=='A')?0:(msize-1);(A=='A')?(i&lt;=msize-1):(i&gt;=0);(A=='A')?(i++):(i--))
	{
		for(j=(A=='A')?0:(msize-1);(A=='A')?(j&lt;=msize-1):(j&gt;=0);(A=='A')?(j++):(j--))
		{
			if(!bd&amp;&amp;(cMap[i][j]==B||cMap[i][j]=='C'))
			{
				tmp=bfs(i,j,A);
				if(tmp.dx+tmp.dy==0) continue;
				bd=true;
				res=tmp;
			}
			if(!bd&amp;&amp;!bm&amp;&amp;(cMap[i][j]==A||cMap[i][j]==a)&amp;&amp;hp[i][j]&gt;1)
			{
				for(k=0;k&lt;4;k++)
				{
					dx=dir[k][0]+i;
					dy=dir[k][1]+j;
					if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize)) continue;
					if((cMap[dx][dy]==0||cMap[dx][dy]==b)&amp;&amp;hp[dx][dy]&lt;hp[i][j]-1)
					{
						bm=true;
						res.dx=dir[k][0];
						res.dy=dir[k][1];
						res.x=i;
						res.y=j;
						break;
					}
				}
			}
			if(bd) break;
		}
		if(bd) break;
	}
	if(!bd&amp;&amp;!bm) return;
	vMoveNum(res.x,res.y,res.dx,res.dy,A);
}

dRet bfs(int x,int y,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	int i,dx,dy;
	dRet ret;
	node now,nxt;
	queue&lt;node&gt;q;
	now.step=hp[x][y]+2;
	now.x=x;
	now.y=y;
	q.push(now);
	memset(bVis,false,sizeof bVis);
	bVis[x][y]=true;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(i=0;i&lt;4;i++)
		{
			dx=dir[i][0]+now.x;
			dy=dir[i][1]+now.y;
			if(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;!bVis[dx][dy]&amp;&amp;cMap[dx][dy]!='X')
			{
				bVis[dx][dy]=true;
				if(cMap[dx][dy]==0) nxt.step=now.step+1;
				if(cMap[dx][dy]==b||cMap[dx][dy]==B||cMap[dx][dy]=='C') nxt.step=now.step+hp[dx][dy]+2;
				else
				{
					nxt.step=now.step-hp[dx][dy]+1;
					if(nxt.step&lt;-5&amp;&amp;(cMap[dx][dy]==A||cMap[dx][dy]==a))
					{
						ret.dx=-dir[i][0];
						ret.dy=-dir[i][1];
						ret.x=dx;
						ret.y=dy;
						return ret;
					}
				}
				nxt.x=dx;
				nxt.y=dy;
				q.push(nxt);
			}
		}
	}
	ret.dx=ret.dy=0;
	return ret;
}

void vPlus()
{
	int i,j,aa=0,ba=0,al=0,bl=0;
	if(nCount%lcnt==0)
	{
		for(i=0;i&lt;msize;i++)
		{
			for(j=0;j&lt;msize;j++)
			{
				if(cMap[i][j]=='a'||cMap[i][j]=='b')
				{
					hp[i][j]++;
					vChange(i,j);
				}
			}
		}
	}
	for(i=0;i&lt;msize;i++)
	{
		for(j=0;j&lt;msize;j++)
		{
			if(cMap[i][j]=='A'||cMap[i][j]=='B')
			{
				hp[i][j]+=pmain;
				vChange(i,j);
			}
			if(cMap[i][j]=='A'||cMap[i][j]=='a') al++,aa+=hp[i][j];
			if(cMap[i][j]=='B'||cMap[i][j]=='b') bl++,ba+=hp[i][j];
		}
	}
	color(15,0);
	gotoxy(msize+2,0);
	cout&lt;&lt;&quot;red army:&quot;&lt;&lt;aa&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;red land:&quot;&lt;&lt;al&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;blue army:&quot;&lt;&lt;ba&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;blue land:&quot;&lt;&lt;bl&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	vEnd();
}

void vEnd()
{

	if(cMap[0][0]=='B')
	{
		cout&lt;&lt;&quot;blue win&quot;&lt;&lt;endl;
		while(1);
	}
	if(cMap[msize-1][msize-1]=='A')
	{
		cout&lt;&lt;&quot;red win&quot;&lt;&lt;endl;
		while(1);
	}
}

void vChange(int x,int y)
{
	int c;
	char cm=cMap[x][y];
	if(cm=='A') c=cA;
	if(cm=='a') c=ca;
	if(cm=='B') c=cB;
	if(cm=='b') c=cb;
	if(cm=='C') c=cC;
	gotoxy(x,y*3);
	color(15,c);
	int val=hp[x][y];
	if(val&lt;10) cout&lt;&lt;&quot; &quot;&lt;&lt;val;
	else if(val&lt;100) cout&lt;&lt;val;
	else if(val&lt;1000) cout&lt;&lt;val/100&lt;&lt;&quot;e&quot;;
	else if(val&lt;10000) cout&lt;&lt;val/1000&lt;&lt;&quot;k&quot;;
	else if(val&lt;100000) cout&lt;&lt;val/10000&lt;&lt;&quot;w&quot;;
	else cout&lt;&lt;&quot;ju&quot;;
}

void gotoxy(int x,int y)
{
	COORD c;
	c.X=y;
	c.Y=x;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),c);
}

void color(int t,int b)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),t+b*16);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[匈牙利算法总结]]></title>
        <id>https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/</id>
        <link href="https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/">
        </link>
        <updated>2022-01-14T12:28:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="part-0前言">Part 0：前言</h3>
<p>学了这个算法好多次了，是时候总结一下啦😆</p>
<h3 id="part-1几个概念">Part 1：几个概念</h3>
<ul>
<li><strong>二分图</strong>：一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。</li>
<li><strong>最大匹配数</strong>：二分图中没有公共端点的边的数量的最大值。</li>
<li><strong>最小点覆盖</strong>：我们想找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。</li>
<li><strong>匈牙利算法</strong>：一种用来解决<strong>最大匹配数</strong>和<strong>最小点覆盖</strong>问题的算法。</li>
</ul>
<h3 id="part-2二分图最大匹配问题">Part 2：二分图最大匹配问题</h3>
<figure data-type="image" tabindex="1"><img src="https://yydcc-blog.github.io//post-images/1642164375763.png" alt="" loading="lazy"></figure>
<p>这里举例一个二分图，来模拟匹配的过程。</p>
<p>很明显，这里的最大匹配是3。</p>
<h4 id="匈牙利算法的过程模拟">匈牙利算法的过程模拟：</h4>
<p>我们先暂时把1和2连在一起。</p>
<p>现在3也可以和2连，这时我们返过去看和2相连的1。</p>
<p>由于1只能和2连，所以3连不上2。</p>
<p>那么3还有选择么？有，可以和6连。</p>
<p>这时6只能和3连。</p>
<p>再看4，和5连即可。</p>
<p>这就是匈牙利算法的流程，至于具体实现，我们来看看代码：</p>
<pre><code class="language-cpp">int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i){
    for (int j = 1; j &lt;= N; ++j)
        if (Map[i][j] &amp;&amp; !vis[j]){ //有边且未访问
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])){ //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian(){
    int cnt = 0;
    for (int i = 1; i &lt;= M; ++i){
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
</code></pre>
<p>通过算法我们可以发现，单次找边的过程是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的，一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点，所以总体复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p>
<p>（因为复杂度大，所以题目的限制一般较大，可以直接用邻接矩阵存储）</p>
<h3 id="part-3二分图最小点覆盖问题">Part 3：二分图最小点覆盖问题</h3>
<p>这里引入<strong>König定理</strong>：</p>
<blockquote>
<p>一个二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
</blockquote>
<p>直接解决。</p>
<h3 id="part-4例题">Part 4：例题</h3>
<p>这里只举例一题：<strong>洛谷 P1129 [ZJOI2007] 矩阵游戏</strong></p>
<blockquote>
<p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：<br>
行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。<br>
列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。<br>
游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。<br>
对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p>
</blockquote>
<p>通过枚举样例，我们发现：任意2个黑色方块，如果它们初始状态时不在同一行（列），那么无论如何交换，它们都不会在同一行（列）。</p>
<p>所以我们只需判断每一行是否都可以合法匹配即可。</p>
<p>AC代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int mp[205][205],p[205],vis[205],n,T;
bool match(int i){
	for(int j=1;j&lt;=n;j++) {
		if(mp[i][j]&amp;&amp;!vis[j]){
			vis[j]=1;
			if(!p[j]||match(p[j])) {
				p[j]=i;
				return 1;
			}
		}
	}
	return 0;
}
int Hungarian(){
	int cnt=0;
	for (int i=1;i&lt;=n;i++) {
		memset(vis,0,sizeof(vis));
		if (match(i))cnt++;
	}
	return cnt;
}
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--){
		scanf(&quot;%d&quot;,&amp;n);
		memset(p,0,sizeof(p));
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf(&quot;%d&quot;,&amp;mp[i][j]);
		if(Hungarian()==n)puts(&quot;Yes&quot;);
		else puts(&quot;No&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="part-5总结">Part 5：总结</h3>
<p>匈牙利算法是一个比较基础的图论算法，思路较简单，一定要记牢啊😙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你好！CSP-J-2021]]></title>
        <id>https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/</id>
        <link href="https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/">
        </link>
        <updated>2022-01-11T12:11:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="day-27">Day -27：</h3>
<p>今年复赛终于进了，压线两分。</p>
<p>我觉得只要进了就好，没别的要求。</p>
<p>S组差亿点点QWQ。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-26">Day -26：</h3>
<p>开始准备复赛。</p>
<p>搞了一些网课什么的，模拟赛打一打。<s>鱼摸一摸</s></p>
<hr>
<h3 id="day-1-afternoon">Day -1 afternoon：</h3>
<p>逃了学校的两堂课，直接出发去酒店。</p>
<p>晚上大吃一顿然后看看防爆零事项什么的。</p>
<p>总体来说准备很充分，剩下的看老天爷了。</p>
<hr>
<h3 id="day-1-night">Day -1 night：</h3>
<p>杭州真的好热，晚上有睡没睡的。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-1-morning">Day 1 morning：</h3>
<p>在酒店大堂吃了顿早餐就出发了。</p>
<p>在门口遇见一堆大佬（wjz ghj yjy sk）</p>
<p>进场时绕了好久，在考场外等了好久。</p>
<hr>
<h3 id="day-1-csp-j-2021">Day 1 CSP-J-2021：</h3>
<p>今年出题人是真的良心。</p>
<p>四道题三道模拟一道暴力。（bushi）</p>
<p>T1就是一道数学题，模几个样例就想到做法了。</p>
<p>然后我先做了T3，根据大样例找了好久的错。</p>
<p>这时比赛已经过半了（T3 98行代码自愧不如）<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<p>T2读了好久的题，草稿纸都快写满了。</p>
<p>突然发现好水然后测了大样例就去做T4了。</p>
<p>T4链表写炸，最后用了个暴力。</p>
<p>一开始直接用肉眼看大样例答案，后来想到可以用cmd的fc，但又不会改目录，就写了一个check来判断。</p>
<hr>
<h3 id="day-1-noon">Day 1 noon：</h3>
<p>比完后在附近吃了饭，然后就退房返城。</p>
<hr>
<h3 id="day-n">Day n:</h3>
<p>洛谷自测300+</p>
<p>J组1=，满足了</p>
<h2 id="再见csp-j-2021">再见！CSP-J-2021</h2>
<h6 id="补充个人认为难度t4t2t3t1">补充：个人认为难度T4&gt;T2&gt;T3&gt;T1</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[yorg.io 进阶攻略]]></title>
        <id>https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/</id>
        <link href="https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/">
        </link>
        <updated>2022-01-09T13:04:17.000Z</updated>
        <content type="html"><![CDATA[<p>这是我精心编写的攻略，喜欢大家喜欢😄</p>
<h3 id="前言">前言</h3>
<p>这是一个休闲类塔防网页游戏，也有单机版。</p>
<p>游戏地址：<a href="https://yorg.io/">link</a></p>
<h3 id="第一步度过前期第1~50天">第一步：度过前期（第1~50天）</h3>
<ul>
<li>基地建在附近有最多水晶的地方，水晶之间距离越近越好。</li>
<li>前十几关都不需要建攻击塔，所有经济用于升级基地、水晶以及建墙，把所有水晶矿机升级到最高级。</li>
<li>前期不用建攻击塔怎么解决掉小兵和boss呢？靠墙拖着，拖到白天，所有小兵和boss都会在3/4的白天前被烧死，基地本身有的攻击力也会发挥作用。建墙有一定的技巧，一是在墙快要被摧毁的时候升级，它就回到满血状态，这样可以把时间拖到最长，操作的注意点是受到攻击时经常性按下暂停，升级墙；二是只需要特别加强4个方向的墙：东南、东北、西南、西北，大部分小兵主要是攻击这4个方向，三是保险一点围2层的墙，在4个方向上可以加到3-4层；</li>
<li>基地升到第6级时，开始建闪电塔，闪电塔是最有效的攻击武器；不要建其他攻击塔；</li>
<li>前期把所有技能点都点到提升矿机生产效率上，然后是工厂生产，最后是闪电攻击；</li>
</ul>
<h4 id="tips">tips:</h4>
<ul>
<li>boss一般是在防御最弱的方向发起攻击的；</li>
<li>如果你的建筑相隔较远，比如矿机、工厂和攻击塔之间，最好将连接的传输器升到最高级，这样可以大大加快运输的速度，快速补充弹药；</li>
<li>如果某一关搞砸了，可以读取存档，不过会损失一些资源；如果你在白天保存游戏，然后回到主界面，再进入，小兵就会消失（算是作弊把..）</li>
</ul>
<h4 id="结束前期这时level10-现有水晶在1千万以上">结束前期，这时Level10+。现有水晶在1千万以上。</h4>
<h3 id="第二步初步转型50天后">第二步：初步转型（50天后）</h3>
<ul>
<li>拆除你的所有设施。</li>
<li>重新安排你的水晶矿机，围绕着主基地排列。</li>
<li>重新安排其他矿机，让他们围绕着水晶矿机排列，我们把这个区域叫做一个矿区。</li>
<li>用运输线连接矿机，将各种工厂安置在运输线上。（如果你已经解锁了空间翘曲技术，请跳过这步）</li>
<li>在每个矿区周围安置弓箭塔8个，闪电塔4个。</li>
</ul>
<h3 id="第三步围墙转型">第三步：围墙转型</h3>
<ul>
<li>如果水晶多，定位到地图的边缘，按住字母E的同时按住ASDW控制方向，绘制出连续的城墙。</li>
<li>如果水晶少，在每个矿区周围搭建围墙。</li>
<li>制造僵尸通道（在围墙上开洞通往主基地）</li>
<li>在这个通道周围布满武器塔。</li>
</ul>
<h3 id="第四步还没有第四步">第四步：还没有第四步😙</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-J2021 题解]]></title>
        <id>https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/</id>
        <link href="https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/">
        </link>
        <updated>2022-01-09T03:08:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分糖果">分糖果</h2>
<h3 id="题意">题意</h3>
<p>选择<code>L~R</code>中的某个数 ， 使得<code>x mod k</code>的结果最大。</p>
<h3 id="思路">思路</h3>
<p>分两种情况考虑：</p>
<p>若 L 和 R 对 K 取模后在同一区间，则必然在 x=R 位置取到最大值；<br>
否则 L~R 必然跨越多个区间，则取模后的结果必然有 k-1。<br>
而对于是否在同一区间，在除以 k 后，商是否一致判断即可。</p>
<h3 id="参考代码">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int main() {
  ll n, l, r;
  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
  if (l / n != r / n) cout &lt;&lt; n - 1 &lt;&lt; endl;
  else cout &lt;&lt; r % n &lt;&lt; endl;
  return 0;
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<h3 id="题意-2">题意</h3>
<p>给定长度为 n 的整数序列 ，有 Q 种操作：</p>
<p>1：x v 修改序列 a 中的第 x 个元素 <code>a[x]</code> 为 v ，该操作次数不超过5000次；<br>
2：x 将数组进行稳定排序，求原先第 x 个元素排序后的位置。</p>
<h3 id="思路-2">思路</h3>
<p>不如维护将原先所有的 a 排序后的升序数组。对于所有操作，我们需要维护原位置到有序数组中的映射。</p>
<p>对于 1 操作，找到 <code>a[x]</code> 对应位置，显然修改值将使其往前或往后。联系到题目中提示的插入排序，可以不断向前/向后比较。注意同时维护映射关系。<br>
对于 2 操作，直接输出映射即可。<br>
注：如果该题中的数组长度更长、操作次数更多，我们可使用平衡树来解决该题。</p>
<h3 id="参考代码-2">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; pii;
const int N = 8e3+5;
int a[N];
pii p[N];

int main() {
  ios::sync_with_stdio(false);
  int n, q; cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i];
    p[i] = {a[i], i};
  }
  sort(p + 1, p + 1 + n);
  for (int i = 1; i &lt;= n; i++) a[p[i].second] = i;
  for (int i = 0, op, x, v; i &lt; q; i++) {
    cin &gt;&gt; op; 
    // 5000 * 8000 = 4e7
    if (op == 1) {
      cin &gt;&gt; x &gt;&gt; v;
      int pos = a[x];
      p[pos].first = v;
      while (pos &gt; 1 &amp;&amp; p[pos] &lt; p[pos - 1]) {
        swap(a[p[pos].second], a[p[pos - 1].second]);
        swap(p[pos], p[pos - 1]);
        pos--;
      } 
      while (pos &lt; n &amp;&amp; p[pos] &gt; p[pos + 1]) {
        swap(a[p[pos].second], a[p[pos + 1].second]);
        swap(p[pos], p[pos + 1]);
        pos++;
      }
    } else {
      cin &gt;&gt; x;
      cout &lt;&lt; a[x] &lt;&lt; endl;
    }
  }
  return 0;
}
</code></pre>
<h2 id="网络连接">网络连接</h2>
<h3 id="题意-3">题意</h3>
<p>解析带端口的IP地址串，按服务器和客户端角色判断连接情况。</p>
<h3 id="思路-3">思路</h3>
<p>若将带端口的IP地址串记为 a.b.c.d:e，则需要检查的项目有：</p>
<ul>
<li>有三个点号和一个冒号分隔字符串，且冒号出现在最后；</li>
<li>a,b,c,d,e均不为空，且不含有前导零；</li>
</ul>
<p>可将对字符串的解析抽象为函数，简化代码逻辑。</p>
<h3 id="参考代码-3">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string, int&gt; dict;
const int IP = 256;
const int PORT = 65536;

bool check(string s, int limit) {
  // &quot;.0.0.1:80&quot; -&gt; &quot;&quot;
  if (s.empty()) return false;
  // &quot;0127.0.0.1:80&quot; -&gt; &quot;0127&quot;
  if (s[0] == '0' &amp;&amp; s.size() &gt; 1) return false;
  int val = 0;
  for (int i = 0; i &lt; s.size(); i++) {
    val = val * 10 + s[i] - '0'; 
    if (val &gt;= limit) return false;
  }
  return true;
}

bool parse(string ip) {
  string s = &quot;&quot;;
  int dot_cnt = 0, port_cnt = 0;
  for (int i = 0; i &lt; ip.size(); i++) {
    if (ip[i] == '.') dot_cnt += 1;
    if (ip[i] == ':') {
      if (dot_cnt != 3) return false;
      port_cnt += 1;
    }
    if (!isdigit(ip[i])) {
      if (!check(s, IP)) return false;
      s = &quot;&quot;;
    } else s += ip[i];
  }
  return check(s, PORT) &amp;&amp; dot_cnt == 3 &amp;&amp; port_cnt == 1;
}

void process_server(string ip, int id) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  dict[ip] = id;
  cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
}

void process_client(string ip) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (!dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  cout &lt;&lt; dict[ip] &lt;&lt; endl;
}

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    string name, ip;
    cin &gt;&gt; name &gt;&gt; ip;
    if (name[0] == 'S') process_server(ip, i);
    else process_client(ip);
  }
  return 0;
}
</code></pre>
<h2 id="小熊的果篮">小熊的果篮</h2>
<h3 id="题意-4">题意</h3>
<p>有两类共 n 个水果拍成一排，称连续的排在一起的同一种水果称为“块”。</p>
<p>每次将每一个“块”中最左边的水果同时挑出。重复该操作直至水果用完。</p>
<p>每次水果被挑出后“块”会发生动态变化。</p>
<h3 id="思路-4">思路</h3>
<p>尝试建模每个块，使用块头来表示每个块的开始位置，即第一个元素或与上一个元素类型不同的位置。</p>
<p>每个元素之间使用双向链表相连接。</p>
<p>对于每次输出选出的元素，我们只需要依次输出块头元素，并从双向链表中删除该元素。</p>
<p>当块头元素输出后，需要更新块头列表。<br>
考虑在原块头位置的下一个元素，只有当：</p>
<ul>
<li>该下一个元素与原块头位置的上一个元素类型不同；</li>
<li>该下一个元素不是原块头。</li>
</ul>
<p>则能够成为新的块头位置。</p>
<h3 id="参考代码-4">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5+5;
struct Node {
  int pre, nxt, v;
}a[N];
vector&lt;int&gt; head, nxt_head;

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  a[0].v = a[n + 1].v = -1;
  a[0].nxt = 1;
  a[n + 1].pre = n;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i].v;
    a[i].pre = i - 1;
    a[i].nxt = i + 1;
    if (a[i].v != a[i - 1].v) head.push_back(i);
  }
  while(head.size()) {
    nxt_head.clear();
    for (int id : head) {
      cout &lt;&lt; id &lt;&lt; &quot; &quot;;
      Node&amp; node = a[id];
      a[node.pre].nxt = node.nxt;
      a[node.nxt].pre = node.pre;
      if (node.v == a[node.nxt].v &amp;&amp; node.v != a[node.pre].v)
        nxt_head.push_back(node.nxt);
    }
    cout &lt;&lt; endl;
    swap(head, nxt_head);
  }
  return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>