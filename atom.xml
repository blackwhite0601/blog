<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yydcc-blog.github.io/</id>
    <title>永远的CC的博客</title>
    <updated>2022-02-02T04:18:13.347Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yydcc-blog.github.io/"/>
    <link rel="self" href="https://yydcc-blog.github.io/atom.xml"/>
    <subtitle>永远的CC，永远为你</subtitle>
    <logo>https://yydcc-blog.github.io/images/avatar.png</logo>
    <icon>https://yydcc-blog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 永远的CC的博客</rights>
    <entry>
        <title type="html"><![CDATA[LIVE-活着]]></title>
        <id>https://yydcc-blog.github.io/post/live-huo-zhao/</id>
        <link href="https://yydcc-blog.github.io/post/live-huo-zhao/">
        </link>
        <updated>2022-01-31T13:48:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>by 黑_白（永远的CC）</p>
<h1 id="代码行数149行">代码行数：149行</h1>
<h1 id="更新日志">更新日志</h1>
<ul>
<li>第一个版本1️⃣</li>
<li>添加了不同人数🚻</li>
<li>添加了对作弊者的惩治☠️</li>
<li>添加了亡语👻</li>
<li>第二个版本2️⃣</li>
<li>避免了自杀🤡</li>
<li>添加了技能🎌</li>
</ul>
<h1 id="判定数字机制">判定数字机制</h1>
<p>第一个1/1<br>
第二个1/2<br>
第三个1/3<br>
第四个1/4<br>
第五个1/5<br>
第六个1/6</p>
<h1 id="技能列表">技能列表</h1>
<ul>
<li>冰冻：跳过杀人阶段</li>
<li>近视：只能杀编号相邻的人（没有编号相邻的人就杀不了QWQ）</li>
</ul>
<h1 id="游戏代码">游戏代码：</h1>
<pre><code class="language-cpp">//LIVE
#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
using namespace std;
void print(char a[]){for(int i=0;i&lt;strlen(a);i++){cout&lt;&lt;a[i];Sleep(10);}puts(&quot;&quot;);}
void cls(){system(&quot;cls&quot;);}
void pause(){system(&quot;pause&quot;);}
void hehe(){print(&quot;小朋友想走不当途径是不好的&quot;);print(&quot;你死了&quot;);exit(1);}
int f,a,last,live[10000],skill[10000];
int main(){
	srand(time(NULL));
	system(&quot;title LIVE-by black_white&quot;);
	system(&quot;MODE CON: COLS=50 LINES=30&quot;);
	std::srand(time(NULL));
	print(&quot;LIVE活着&quot;);pause();cls();
	print(&quot;by 黑_白（永远的CC）&quot;);pause();cls();
	printf(&quot;输入人数（推荐7人）：&quot;);
	cin&gt;&gt;last;
	if(last&lt;=0)hehe();
	for(int i=1;i&lt;=last;i++)live[i]=i;
	print(&quot;规则：一共n个人，每个人选择一个击杀目标，最后剩下的人胜利&quot;);pause();cls();
	print(&quot;游戏开始！&quot;);cls();
	printf(&quot;输入你的编号（1~n）：&quot;);
	cin&gt;&gt;a;cls();
	if(a==114514)print(&quot;成功开启人机对打！&quot;);
	else if(!(a&gt;=1&amp;&amp;a&lt;=last))hehe();
	cls();
	for(int I=1;;I++){
		cls();
		printf(&quot;--------------------------------------------------\n&quot;);
		printf(&quot;第%d个回合：\n&quot;,I);
		for(int i=1;i&lt;=last;i++){
			if(live[i]==0)continue;
			int Cnt=0;
			for(int j=1;j&lt;=last;j++)if(live[j]!=0)Cnt++;
			printf(&quot;还剩%d人\n&quot;,Cnt);
			printf(&quot;还活着的人：&quot;);
			for(int j=1;j&lt;=last;j++)if(live[j]!=0)printf(&quot;%d &quot;,live[j]);
			puts(&quot;&quot;);
			if(skill[i]==1){
				printf(&quot;%d号解冻\n&quot;,i);
				skill[i]=0;
				continue;
			}
			int mb=rand()%(last+1);
			while(live[mb]==0&amp;&amp;mb==i&amp;&amp;mb==0)mb=rand()%(last+1);
			if(a!=live[i])printf(&quot;%d选择了%d号\n&quot;,live[i],live[mb]);
			else{
				printf(&quot;你的目标是（输入0放弃猎杀）：&quot;);
				cin&gt;&gt;mb;
				bool ff=0;
				for(int j=1;j&lt;=last;j++)if(live[j]==mb)ff=1;
				if(!ff)hehe();
			}
			if(mb==0){
				print(&quot;他放弃了猎杀...&quot;);
				getch();
				continue;
			}
			if(skill[i]==2){
				if(mb-i&gt;1||mb-i&lt;-1){
					print(&quot;近视生效...&quot;);
					print(&quot;打不到目标...&quot;);
					skill[i]=0;
					continue;
				}
				skill[i]=0;
			}
			print(&quot;正在生成判定数字...\n&quot;);
			int pd[7],cnt=1;memset(pd,0,sizeof(pd));
			for(int j=1;j&lt;=6;j++){
				int t=rand()%j;
				if(t!=0)break;
				int tt=rand()%6;
				pd[cnt]=tt;
				cnt++;
			}
			printf(&quot;可判定的数字为：&quot;);
			for(int j=1;j&lt;=cnt;j++)pd[j]++,printf(&quot;%d &quot;,pd[j]);
			puts(&quot;&quot;);
			int s=rand()%3;
			if(s==0){
				print(&quot;有人篡改了判定数字。&quot;);
				pd[rand()%cnt+1]=rand()%6+1;
				printf(&quot;现可判定的数字为：&quot;);
				for(int j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,pd[j]);
				puts(&quot;&quot;);
			}
			getch();
			int sz=rand()%6;sz++;
			printf(&quot;%d号抛出了%d\n&quot;,live[i],sz);
			bool kill=0;
			for(int i=1;i&lt;=cnt;i++)
				if(sz==pd[i]){
					kill=1;
					break;
				}
			if(!kill)print(&quot;未杀死目标。\n&quot;),getch();
			else{
				int ttt=rand()%3;
				if(ttt&gt;0){
					live[mb]=0,print(&quot;成功杀死目标！\n&quot;);
					int tttt=rand()%2;
					if(tttt){
						int mb3=rand()%(last+1);
						while(live[mb3]==0&amp;&amp;mb3==i&amp;&amp;mb3==0)mb3=rand()%(last+1);
						printf(&quot;并发动技能：&quot;);
						int aa=rand()%2;
						if(aa==0){
							printf(&quot;冻结\n&quot;);
							printf(&quot;%d号被冻结了。\n&quot;,mb3);
							skill[mb3]=1;
						}else if(aa==1){
							printf(&quot;近视\n&quot;);
							printf(&quot;%d号近视了。\n&quot;,mb3);
							skill[mb3]=2;
						}
					}
					getch();
				}
				else{
					int mb2=rand()%(last+1);
					while(live[mb2]==0&amp;&amp;mb==mb2&amp;&amp;mb2==0)mb2=rand()%(last+1);
					printf(&quot;%d号复活了，并随机诅咒了%d号\n&quot;,live[mb],live[mb2]);
					getch();
					int tttt=rand()%2;
					if(tttt)printf(&quot;%d号死了\n&quot;,live[mb2]),live[mb2]=0;
					else printf(&quot;但他没死。\n\n&quot;);
					getch();
				}
			}
			int sum=0;
			for(int i=1;i&lt;=last;i++)if(live[i]!=0)sum++;
			if(sum==0){
				cls();
				print(&quot;每个人都倒下了...&quot;);
				print(&quot;无人胜利...&quot;);
				pause();
				return 0;
			}
			if(sum==1){
				for(int k=1;k&lt;=last;k++)
					if(live[k]!=0){
						printf(&quot;%d挺到了最后...\n&quot;,live[k]);
						if(k==a)print(&quot;你胜利了！&quot;);
						pause();
						return 0;
					}
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[人类沦陷-史诗级巨作]]></title>
        <id>https://yydcc-blog.github.io/post/ren-lei-lun-xian-shi-shi-ji-ju-zuo/</id>
        <link href="https://yydcc-blog.github.io/post/ren-lei-lun-xian-shi-shi-ji-ju-zuo/">
        </link>
        <updated>2022-01-31T03:55:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>黑_白(永远的CC)和段建泽共同出品。</p>
<h1 id="剧情">剧情</h1>
<h2 id="总剧情">总剧情</h2>
<blockquote>
<p>在千年以前，有一群人类被感染成了异种<br>
它们变得与常人不同,拥有更强大的力量与更强大的身体<br>
正常人类带着排斥接受着它们<br>
不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性<br>
人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石<br>
那次人类使出了全力对抗异种<br>
双方死伤惨重,人类花了200年才恢复过来<br>
而人类异种从此销声匿迹<br>
但现在，他们卷土重来了！！！<br>
作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？</p>
</blockquote>
<h2 id="分剧情1default最后堡垒">分剧情1：default:最后堡垒</h2>
<blockquote>
<p>这是人类最后的希望...<br>
你将坚守最后的城池，保卫身后那颗普蓝色的定界石<br>
这个阶段，史称<br>
最后堡垒!!!</p>
</blockquote>
<h2 id="分剧情2beta失落城邦">分剧情2：beta:失落城邦</h2>
<blockquote>
<p>人类从曾经摔倒的地方重新站起<br>
我们即将迎来第一场反击战!<br>
目光灼灼地望向前方，那曾是我们的家园<br>
这个阶段，史称<br>
失落城邦!!!</p>
</blockquote>
<h1 id="攻略">攻略</h1>
<pre><code>首先，你可以一直按0大约10次，攒到大约200
然后，你可以建一层护盾和一个哨兵塔，用来进攻
接着，继续攒钱，建高射炮来防御坦克及飞机
最后，只需要在建筑有破损时重建就行了
</code></pre>
<h1 id="各世界属性">各世界属性</h1>
<pre><code>造物主模式初始资源很多
生存模式资源中等
衰竭模式资源匮乏，每回合我方扣固定的100血量
</code></pre>
<h1 id="tips">Tips</h1>
<pre><code>高射炮不仅可以打飞机，把它压下来也可以打地面敌人！
迫击炮不仅可以打小兵，还能打敌方基地！
小兵打敌方基地的伤害十分可观。
导弹可以直接打对方的基地！
千万别让小兵接近你的基地，你的建筑十分危险！
激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！
护盾可以抵挡敌方的一次远程进攻哦！
克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用
岩石地雷可以在五回合后炸死敌方所有小兵哦！
晶坷垃是一种新型货币，不可与金币互换。
头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。
歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。
</code></pre>
<h1 id="游戏代码">游戏代码</h1>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;ctime&gt;
#include&lt;windows.h&gt;
#include&lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include&lt;mmsystem.h&gt;
//#pragma comment(lib, &quot;winmm.lib&quot;)
using namespace std;
int e,g=50,o1=3000,o2,e1=3000,e2,o1_max=3000,Lv;//金币：g, 晶坷垃 jkl
int s,l,sl,pj,dd,i,ts,k,tk,tke,tkk,xx,bt,gs,fj,fje,jjj,jjje;
int fk,jg,jk,hd,hde,jd,jde,zx,iii,pz,lzpz,pze,lzpze;
int dl,dle,jkl,jkl_kc,tt,zd,reblood,water;
//bdaguai
int Rand;
int dgsr;
int fy=15;
int gj=30;
int Rand2;
int hp=100;
int gwhp;
int moneyrand;
int jbrand;
int jklrand;
int mjrand;
int gfrand;
int grand;
int frand;
int dgcs;
//bdaguai
int hxcs;
//kaibx
int ksr;
int gbrand1;
int jklrand1;
int Rand1;
int gfrand1;
int grand1;
int frand1;
int kxcs;
int zjay;//买到终极宝箱（终极奥义）1
int fxjs;//买宝箱20次  （奉献精神）1
int gwlr;//杀死20个怪  （怪物猎人）1
int hxds;//买回血器5个 （回血大师）1
int dgds;//打死十级怪物（打怪大师）1
//（打怪大师）
//（终极奥义）
//（奉献精神）
//（怪物猎人）
//（回血大师）
//kaibx
//2048
int game_answer=0;
//2048
char d,ch;
bool beta;
string ssss;
//cj
int qqqq;
int www,jjj1,zzz,lll,vvv,hhh;
int cjcs;
//cj
/*设置背景颜色*/int setBackColor(unsigned char bColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;csbInfo);
    return SetConsoleTextAttribute(hd, (bColor &lt;&lt; 4) | (csbInfo.wAttributes&amp;~0xF0));
}
void appGotoXY(int x,int y)  //移动光标
{
    swap(x,y);
    CONSOLE_SCREEN_BUFFER_INFO    csbiInfo;
    HANDLE    hConsoleOut;
    hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsoleOut,&amp;csbiInfo);
    csbiInfo.dwCursorPosition.X = x;
    csbiInfo.dwCursorPosition.Y = y;
    SetConsoleCursorPosition(hConsoleOut,csbiInfo.dwCursorPosition);
}
void appGetXY() //得到光标位置
{
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO pBuffer;
    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hStdout, &amp;pBuffer);
    cout &lt;&lt; pBuffer.dwCursorPosition.X &lt;&lt;&quot; &quot;&lt;&lt; pBuffer.dwCursorPosition.Y &lt;&lt;endl;;
}
/*设置字体颜色*/int setTextColor(unsigned char fColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;csbInfo);
    return SetConsoleTextAttribute(hd, fColor | (csbInfo.wAttributes&amp;~0x0F));
}
void START(){
    appGotoXY(0,0);
    setBackColor(15);//大背景颜色
    for(int i=1;i&lt;=26*80;i++)
        cout&lt;&lt;&quot; &quot;;
    appGotoXY(0,0);
    cout&lt;&lt;&quot; &quot;;
    appGotoXY(20,19);
    setBackColor(7);//小背景颜色
    for(int i=1;i&lt;=42;i++)
        cout&lt;&lt;&quot; &quot;;
    setTextColor(0);//字体颜色
    appGotoXY(3,19);
    printf(&quot;┏━━━━┳━━━━┳━━━━┳━━━━┓\n&quot;);
    appGotoXY(4,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(5,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(6,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(7,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(8,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(9,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(10,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(11,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(12,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(13,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(14,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(15,19);
    printf(&quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&quot;);
    appGotoXY(16,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(17,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(18,19);
    printf(&quot;┃        ┃        ┃        ┃        ┃\n&quot;);
    appGotoXY(19,19);
    printf(&quot;┗━━━━┻━━━━┻━━━━┻━━━━┛\n&quot;);
    //Sleep(100000);
    return ;
}
inline int Get_X(int x,int y){
    if(x==1)    return 5;
    if(x==2)    return 9;
    if(x==3)    return 13;
    if(x==4)    return 17;
}
inline int Get_Y(int x,int y){
    if(y==1)    return 24;
    if(y==2)    return 34;
    if(y==3)    return 44;
    if(y==4)    return 54;
}

void HideCursor(){//隐藏光标
    CONSOLE_CURSOR_INFO cursor_info = {1, 0};
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);
}

int a[5][5];
bool if_game_over(){
    for(int i=1;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++)
            if(!a[i][j])
                return 1;
    for(int i=2;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++){
            if(a[j][i]==a[j][i-1])
                return 1;
            if(a[i][j]==a[i-1][j])
                return 1;
        }
    return 0;
}
bool vis[20];

void Pr_a_num_with_color(int x){
    switch (x){/*
        1 = 蓝色   9  = 淡蓝色
        2 = 绿色   10 = 淡绿色
        3 = 湖蓝色 11 = 淡浅绿色
        4 = 红色   12 = 淡红色
        5 = 紫色   13 = 淡紫色
        6 = 黄色   14 = 淡黄色
        7 = 白色   15 = 亮白色*/
        case 2:setTextColor(9);printf(&quot;CE&quot;);setTextColor(0);break ;
        case 4:setTextColor(10);printf(&quot;RE&quot;);setTextColor(0);break ;
        case 8:setTextColor(11);printf(&quot;TLE&quot;);setTextColor(0);break ;
        case 16:setTextColor(12);printf(&quot;MLE&quot;);setTextColor(0);break ;
        case 32:setTextColor(13);printf(&quot;ILE&quot;);setTextColor(0);break ;
        case 64:setTextColor(14);printf(&quot;OLE&quot;);setTextColor(0);break ;
        case 128:setTextColor(15);printf(&quot;UKE&quot;);setTextColor(0);break ;
        case 256:setTextColor(1);printf(&quot;WA&quot;);setTextColor(0);break ;
        case 512:setTextColor(2);printf(&quot;AC&quot;);setTextColor(0);break ;
        case 1024:setTextColor(3);printf(&quot;AU&quot;);setTextColor(0);break ;
        case 2048:setTextColor(4);printf(&quot;AK&quot;);setTextColor(0);break ;
    }
}

void Pr_all_num(){
    for(int i=1;i&lt;=4;i++)
        for(int j=1;j&lt;=4;j++){
            int x=Get_X(i,j),y=Get_Y(i,j);
            appGotoXY(x,y);
            if(a[i][j]==0)
                printf(&quot;    &quot;);
            else{
                Pr_a_num_with_color(a[i][j]);
                //printf(&quot;%4d&quot;,a[i][j]);
            }
        }
    return ;
}
//**************************************************
bool clear_up(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=3;i&gt;=1;i--)
            for(int j=1;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i+1][j]!=0){
                    swap(a[i][j],a[i+1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_up(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_up())//没空间不能移动
        bb=0;
    for(int j=1;j&lt;=4;j++){
        int i=1;
        while(i&lt;4){
            if(!a[i+1][j])
                break ;
            if(a[i][j]!=a[i+1][j]){
                i++;
                continue ;
            }
            if(a[i][j]==a[i+1][j]){
                a[i][j]+=a[i+1][j]; game_answer+=a[i+1][j];
                a[i+1][j]=0;
                i+=2;
                bb=1;//可以合并
            }
        }
    }
    if(bb==0)//没空间又不能合并
        return 0;
    clear_up();
    return 1;
}
//**************************************************
bool clear_down(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=2;i&lt;=4;i++)
            for(int j=1;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i-1][j]!=0){
                    swap(a[i][j],a[i-1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_down(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_down())
        bb=0;
    for(int j=1;j&lt;=4;j++){
        int i=4;
        while(i&gt;1){
            if(!a[i-1][j])
                break ;
            if(a[i][j]!=a[i-1][j]){
                i--;
                continue ;
            }
            if(a[i][j]==a[i-1][j]){
                a[i][j]+=a[i-1][j];  game_answer+=a[i-1][j];
                a[i-1][j]=0;
                i-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_down();
    return 1;
}
//**************************************************
bool clear_left(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=1;i&lt;=4;i++)
            for(int j=3;j&gt;=1;j--)
                if(a[i][j]==0&amp;&amp;a[i][j+1]!=0){
                    swap(a[i][j],a[i][j+1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_left(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_left())
        bb=0;
    for(int i=1;i&lt;=4;i++){
        int j=1;
        while(j&lt;4){
            if(!a[i][j+1])
                break ;
            if(a[i][j]!=a[i][j+1]){
                j++;
                continue ;
            }
            if(a[i][j]==a[i][j+1]){
                a[i][j]+=a[i][j+1];  game_answer+=a[i][j+1];
                a[i][j+1]=0;
                j+=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_left();
    return 1;
}
//**************************************************
bool clear_right(){
    bool bb=0;
    for(int k=1;k&lt;=4;k++)
        for(int i=1;i&lt;=4;i++)
            for(int j=2;j&lt;=4;j++)
                if(a[i][j]==0&amp;&amp;a[i][j-1]!=0){
                    swap(a[i][j],a[i][j-1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_right(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_right())
        bb=0;
    for(int i=1;i&lt;=4;i++){
        int j=4;
        while(j&gt;1){
            if(!a[i][j-1])
                break ;
            if(a[i][j]!=a[i][j-1]){
                j--;
                continue ;
            }
            if(a[i][j]==a[i][j-1]){
                a[i][j]+=a[i][j-1];  game_answer+=a[i][j-1];
                a[i][j-1]=0;
                j-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_right();
    return 1;
}
void END(){
    setBackColor(15);
    appGotoXY(21,30);
    char s_1[30]=&quot;游戏结束，您的得分为：&quot;;
    for(int i=0;i&lt;22;i++){
        cout&lt;&lt;s_1[i];
        Sleep(30);
    }
    Sleep(500);
    cout&lt;&lt;game_answer&lt;&lt;endl;
    g+=game_answer;
    Sleep(500);
    appGotoXY(22,30);
    char s_2[30]=&quot;请按任意键结束游戏。&quot;;
    for(int i=0;i&lt;20;i++){
        cout&lt;&lt;s_2[i];
        Sleep(30);
    }
}
void rlsb(){
    srand(time(0));
    HideCursor();//隐藏光标

    START();

    while(if_game_over()){
        //system(&quot;cls&quot;);
        //appGotoXY(0,0);

        int bb=0;//bb判断是否有空位
        for(int i=1;i&lt;=4;i++)
            for(int j=1;j&lt;=4;j++)
                if(!a[i][j])
                    bb=1;
        if(bb==1){
            int num_new=rand()%10+1;//新出现4还是2
            if(num_new==1)  num_new=4;
            else    num_new=2;
            int place_new=0,x=0,y=0;
            while(1){
                place_new=rand()%16+1;
                x=(place_new-1)/4+1,y=place_new%4+1;
                if(!a[x][y])
                    break ;
            }
            a[x][y]=num_new;
        }

        Pr_all_num();

    again:
        char ch_1=getch(),ch_2;
        if(ch_1!=-32){
            appGotoXY(20,30);
            char s_1[30]=&quot;您输入的字符不合法。&quot;;
            for(int i=0;i&lt;20;i++){
                cout&lt;&lt;s_1[i];
                Sleep(1);
            }
            Sleep(200);
            for(int i=1;i&lt;=19;i++)
                printf(&quot;\b \b&quot;);
            goto again;
        }
        ch_2=getch();
        if(ch_2==72)//up
            if(!do_up())
                goto again;
        if(ch_2==80)//down
            if(!do_down())
                goto again;
        if(ch_2==75)//left
            if(!do_left())
                goto again;
        if(ch_2==77)//right
            if(!do_right())
                goto again;
        appGotoXY(20,30);
        printf(&quot;您当前的总分为:%d&quot;,game_answer);
    }
    appGotoXY(20,30);
    printf(&quot;                     &quot;);
    END();
    return;
}
void cj(){
	system(&quot;cls&quot;);
	while(1){
		giao:
		system(&quot;cls&quot;);
		printf(&quot;0 退出\n&quot;);
		printf(&quot;1 查看几率\n&quot;);
		printf(&quot;2 抽奖\n&quot;);
		printf(&quot;纯属娱乐\n&quot;);
		scanf(&quot;%d&quot;,&amp;qqqq);
		if(qqqq==0) return;
		if(qqqq==1){
			system(&quot;cls&quot;);
			printf(&quot;200次%65几率抽到金色传说，%10抽中透明无敌\n&quot;);
			printf(&quot;100次%30几率抽到金色传说，%5抽中透明无敌\n&quot;);
			printf(&quot;50次%15几率抽到金色传说，%2抽中透明无敌\n&quot;);
			printf(&quot;10次%4几率抽到金色传说，%1抽中透明无敌\n&quot;);
			printf(&quot;5次%2几率抽中金色传说，%0.5抽中透明无敌\n&quot;);
			printf(&quot;1次%0.4几率抽中金色传说，%0.1抽中透明无敌\n&quot;);
			Sleep(5000);
		}else if(qqqq==2){
			printf(&quot;输入次数：\n&quot;);
			scanf(&quot;%d&quot;,&amp;cjcs);
			if(g&lt;cjcs*5){
				system(&quot;cls&quot;);
				printf(&quot;钱不够\n&quot;);
				Sleep(5000);
				goto giao;
			}else{
				system(&quot;cls&quot;);
				g-=cjcs*5;
				while(cjcs--){
					int x=std::rand()%1000*rand()%10000;
					if(x&lt;=1){
						printf(&quot;透明无敌！！！\n&quot;);
						MessageBox(NULL,&quot;你竟然抽中了爆率为%0.1的透明无敌！&quot;,&quot;透明无敌！&quot;,MB_OK);
						www++;
						goto f;
					}
					if(x&lt;=30){
						printf(&quot;金色传说！\n&quot;);
						MessageBox(NULL,&quot;金色传说&quot;,&quot;nb&quot;,MB_OK);
						jjj1++;
						goto f;
					}
					if(x&lt;=100){
						printf(&quot;紫色史诗\n&quot;);
						zzz++;
						goto f;
					}
					if(x&lt;=1000){
						printf(&quot;蓝色精英\n&quot;);
						lll++;
						goto f;
					}
					if(x&lt;=2000){
						printf(&quot;绿色普通\n&quot;);
						vvv++;
						goto f;
					}
					printf(&quot;灰色渣渣\n&quot;),hhh++;
					f:
					Sleep(30);
				}
				printf(&quot;透明无敌：%d\n&quot;,www);
				printf(&quot;金色传说：%d\n&quot;,jjj1);
				printf(&quot;紫色史诗：%d\n&quot;,zzz);
				printf(&quot;蓝色精英：%d\n&quot;,lll);
				printf(&quot;绿色普通：%d\n&quot;,vvv);
				printf(&quot;灰色渣渣：%d\n&quot;,hhh);
				Sleep(3000);
				goto giao;
			}
		}
	}
}
void kaibx(){
	bugo:
	if(kxcs&gt;=20&amp;&amp;fxjs!=1){
		fxjs=1;
		system(&quot;cls&quot;);
		printf(&quot;恭喜你取得了奉献精神的成就！！！\n&quot;);
		Sleep(5000);
		printf(&quot;奖励50晶坷垃,150金币&quot;);
		g+=150;
		jkl+=50;
		Sleep(5000);
	}
	system(&quot;cls&quot;);
	printf(&quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&quot;);
	printf(&quot;▉                宝箱                ▉\n&quot;);
	printf(&quot;▉1.  木头宝箱（10金币）              ▉\n&quot;);
	printf(&quot;▉2.  白银宝箱（20金币）              ▉\n&quot;);
	printf(&quot;▉3.  黄金宝箱（20金币，10晶坷垃）    ▉\n&quot;);
	printf(&quot;▉4.  钻石宝箱（50金币，20晶坷垃）    ▉\n&quot;);
	printf(&quot;▉5.  电击宝箱（100金币，40晶坷垃）   ▉\n&quot;);
	printf(&quot;▉6.  雷电宝箱（500金币，100晶坷垃）  ▉\n&quot;);
	printf(&quot;▉7.  终极宝箱（5000金币，500晶坷垃） ▉\n&quot;);
	printf(&quot;▉8.  退出                            ▉\n&quot;);
	printf(&quot;▉▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▉\n&quot;);
	printf(&quot;  金币：%d                              \n&quot;,g);
	printf(&quot;  晶坷垃：%d                            \n&quot;,jkl);
	printf(&quot;  开箱次数：%d                          \n&quot;,kxcs);
	printf(&quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&quot;);
	scanf(&quot;%d&quot;,&amp;ksr);
	if(ksr==0){
		return;
	}
	if(ksr==1){
		if(g&gt;=10){
			kxcs++;
			g-=10;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%15+5;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%6+2;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==2){
		if(g&gt;=20){
			kxcs++;
			g-=20;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%25+10;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%15+5;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==3){
		if(g&gt;=20 &amp;&amp; jkl&gt;=10){
			kxcs++;
			g-=20;
			jkl-=10;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%35+25;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%15+15;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%5+3;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%5+3;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==4){
		if(g&gt;=50 &amp;&amp; jkl&gt;=20){
			kxcs++;
			g-=50;
			jkl-=20;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%60+30;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%40+30;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%10+5;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%10+5;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==5){
		if(g&gt;=100 &amp;&amp; jkl&gt;=40){
			kxcs++;
			g-=100;
			jkl-=40;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%190+80;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%100+40;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%20+5;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%20+5;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==6){
		if(g&gt;=500 &amp;&amp; jkl&gt;=100){
			kxcs++;
			g-=500;
			jkl-=100;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%700+250;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%250+70;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%30+10;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%30+10;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==7){
		if(g&gt;=5000 &amp;&amp; jkl&gt;=500){
			if(zjay!=1){
				zjay=1;
				system(&quot;cls&quot;);
				printf(&quot;恭喜你取得了终极奥义的成就！！！\n&quot;);
				Sleep(5000);
				printf(&quot;奖励100晶坷垃,500金币&quot;);
				g+=500;
				jkl+=100;
				Sleep(5000);
			}
			kxcs++;
			g-=5000;
			jkl-=500;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%5000+3500;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d金币\n&quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%2000+700;
				system(&quot;cls&quot;);
				printf(&quot;奖励%d晶坷垃&quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&quot;cls&quot;);
					grand1=std::rand()%100+30;
					printf(&quot;奖励%d攻击力&quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&quot;cls&quot;);
					frand1=std::rand()%100+30;
					printf(&quot;奖励%d防御力&quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(4000);
			goto bugo;
		}
	}
}
void bdaguai(){
	shengli:
	if(dgcs&gt;=20&amp;&amp;gwlr!=1){
		gwlr=1;
		system(&quot;cls&quot;);
		printf(&quot;恭喜你取得了怪物猎人的成就！！！\n&quot;);
		Sleep(5000);
		printf(&quot;奖励20晶坷垃,100金币&quot;);
		g+=100;
		jkl+=20;
		Sleep(5000);
	}
	system(&quot;cls&quot;);
	printf(&quot;杀死怪物：%d\n&quot;,dgcs);
	printf(&quot;血量：%d\n&quot;,hp);
	printf(&quot;攻击力：%d\n&quot;,gj);
	printf(&quot;防御力：%d\n&quot;,fy);
	printf(&quot;1. 购买血瓶(10$/20hp)\n&quot;);
	printf(&quot;2. 返回\n&quot;);
	printf(&quot;3. 继续\n&quot;);
	scanf(&quot;%d&quot;,&amp;dgsr);
	if(dgsr==2) return;
	else if(dgsr==1){
		if(g&lt;20){
			system(&quot;cls&quot;);
			printf(&quot;钱不够\n&quot;);
			Sleep(2000);
			goto shengli;
		}else{
			g-=10;
			hp+=20;
			system(&quot;cls&quot;);
			printf(&quot;回血成功\n&quot;);
			Sleep(2000);
			goto shengli;
		}
	}else if(dgsr==3){
		system(&quot;cls&quot;);
		if(hp&lt;=0){
			system(&quot;cls&quot;);
			printf(&quot;血量不足无法冒险\n&quot;);
			printf(&quot;1. 购买血瓶(10$/20hp)\n&quot;);
			printf(&quot;2. 返回\n&quot;);
			scanf(&quot;%d&quot;,&amp;dgsr);
			if(dgsr==2) return;
			else{
				if(g&lt;20){
					system(&quot;cls&quot;);
					printf(&quot;钱不够\n&quot;);
					Sleep(2000);
					goto shengli;
				}else{
					g-=10;
					hp+=20;
					system(&quot;cls&quot;);
					printf(&quot;回血成功\n&quot;);
					Sleep(2000);
					goto shengli;
				}
			}
			return;
		}
		Rand=std::rand()%10+1;
		gwhp=Rand*30;
		printf(&quot;你遇到了%d级怪物\n&quot;,Rand);
		printf(&quot;血量：%d\n&quot;,hp);
		printf(&quot;攻击力：%d\n&quot;,gj);
		printf(&quot;防御力：%d\n&quot;,fy);
		printf(&quot;怪物血量：%d\n&quot;,gwhp);
		printf(&quot;怪物攻击力：%d\n&quot;,Rand*10);
		printf(&quot;怪物防御力：%d\n&quot;,Rand*5);
		printf(&quot;1. 迎战\n&quot;);
		printf(&quot;2. 逃跑\n&quot;);
		scanf(&quot;%d&quot;,&amp;dgsr);
		if(dgsr==2) goto shengli;
		else{
			while(1){
				system(&quot;cls&quot;);
				printf(&quot;血量：%d\n&quot;,hp);
				printf(&quot;攻击力：%d\n&quot;,gj);
				printf(&quot;防御力：%d\n&quot;,fy);
				printf(&quot;怪物血量：%d\n&quot;,gwhp);
				printf(&quot;怪物攻击力：%d\n&quot;,Rand*10);
				printf(&quot;怪物防御力：%d\n&quot;,Rand*5);
				printf(&quot;1. 攻击\n&quot;);
				printf(&quot;2. 防御\n&quot;);
				scanf(&quot;%d&quot;,&amp;dgsr);
				if(dgsr==1){
					system(&quot;cls&quot;);
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&quot;cls&quot;);
						printf(&quot;怪物暴击\n&quot;);
						hp-=(Rand*20-fy);
						if(hp&lt;=0){
							system(&quot;cls&quot;);
							printf(&quot;KO\n&quot;);
							Sleep(2000);
							return;
						}
						Sleep(2000);
					}else{
						hp-=(Rand*10-fy);
						if(hp&lt;=0){
							system(&quot;cls&quot;);
							printf(&quot;KO\n&quot;);
							Sleep(2000);
							return;
						}
					}
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&quot;cls&quot;);
						printf(&quot;暴击&quot;);
						gwhp-=(gj*2-Rand*5);
						if(gwhp&lt;=0){
							dgcs++;
							if(Rand==10) dgds=1;
							system(&quot;cls&quot;);
							printf(&quot;胜利\n&quot;);
							mjrand=std::rand()%3;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&quot;奖励%d金币\n&quot;,jbrand);
								g+=jbrand;
							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+1;
								printf(&quot;奖励%d晶坷垃\n&quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d攻击力\n&quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d防御力\n&quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
						Sleep(2000);
					}else{
						gwhp-=(gj-Rand*5);
						if(gwhp&lt;=0){
							dgcs++;
							if(Rand==10 &amp;&amp; dgds!=1){
								dgds=1;
								system(&quot;cls&quot;);
								printf(&quot;恭喜你取得了打怪大师的成就！！！\n&quot;);
								Sleep(5000);
								printf(&quot;奖励200晶坷垃,1000金币&quot;);
								g+=1000;
								jkl+=200;
								Sleep(5000);
							}
							system(&quot;cls&quot;);
							printf(&quot;胜利\n&quot;);
							mjrand=std::rand()%5;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&quot;奖励%d金币\n&quot;,jbrand);
								g+=jbrand;

							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+5;
								printf(&quot;奖励%d晶坷垃\n&quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d攻击力\n&quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&quot;增加%d防御力\n&quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
					}
				}
			}
		}
	}
}
void xs(char ccc){
	cout&lt;&lt;&quot;金币数($)：&quot;&lt;&lt;g&lt;&lt;endl;
	cout&lt;&lt;&quot;晶坷垃(G)：&quot;&lt;&lt;jkl&lt;&lt;endl;
	cout&lt;&lt;&quot;我方人数：&quot;&lt;&lt;o2+jde&lt;&lt;endl;
	cout&lt;&lt;&quot;敌方人数：&quot;&lt;&lt;e2+jd&lt;&lt;endl;
	cout&lt;&lt;&quot;我方血量：&quot;&lt;&lt;o1&lt;&lt;endl;
	cout&lt;&lt;&quot;敌方血量：&quot;&lt;&lt;e1&lt;&lt;endl;
	if(beta) cout&lt;&lt;&quot;主塔级别：&quot;&lt;&lt;Lv&lt;&lt;endl;
	if(ccc=='3') cout&lt;&lt;&quot;已生存天数：&quot;&lt;&lt;iii&lt;&lt;endl;
	if(zx!=0) cout&lt;&lt;&quot;已处于诈降状态&quot;&lt;&lt;endl;
	return ;
}
void bg();
void aa(string sssss){
	if(e1&lt;1000) bg();
	if(ssss==&quot;16391639&quot;){
		g=50000;
		e1=1000000;
		hd=10;
		o1=5000;
	}
	if(ssss!=&quot;test&quot;&amp;&amp;ssss!=&quot;16391639&quot;){
		cout&lt;&lt;&quot;在千年以前，有一群人类被感染成了异种\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;它们变得与常人不同,拥有更强大的力量与更强大的身体\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;正常人类带着排斥接受着它们\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;那次人类使出了全力对抗异种\n&quot;;
		Sleep(2000);
		cout&lt;&lt;&quot;双方死伤惨重,人类花了200年才恢复过来\n&quot;;
		cout&lt;&lt;&quot;而人类异种从此销声匿迹\n&quot;;
		Sleep(2000);
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;但现在，他们卷土重来了！！！&quot;;
		Sleep(2000);
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？&quot;;
		Sleep(2000);
	}
	while(true){
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;请选择模式\n&quot;;
		cout&lt;&lt;&quot;1 default:最后堡垒\n&quot;;
		cout&lt;&lt;&quot;2 beta:失落城邦\n&quot;;
		ch=getch();
		system(&quot;cls&quot;);
		if(ch=='1'){
			if(MessageBox(NULL,&quot;你真的要进入default模式吗？&quot;,&quot;提示&quot;,MB_YESNO)==IDYES){
				cout&lt;&lt;&quot;这是人类最后的希望...\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;你将坚守最后的城池，保卫身后那颗普蓝色的定界石\n&quot;;
				Sleep(3500);
				cout&lt;&lt;&quot;这个阶段，史称\n&quot;;
				Sleep(1000);
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;最后堡垒!!!\n&quot;;
				break;
			}
		}
		else if(ch=='2'){
			if(MessageBox(NULL,&quot;你真的要进入beta模式吗？&quot;,&quot;提示&quot;,MB_YESNO)==IDYES){
				cout&lt;&lt;&quot;人类从曾经摔倒的地方重新站起\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;我们即将迎来第一场反击战!\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;目光灼灼地望向前方，那曾是我们的家园\n&quot;;
				Sleep(2000);
				cout&lt;&lt;&quot;这个阶段，史称\n&quot;;
				Sleep(2000);
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;失落城邦!!!\n&quot;;
				beta=true;
				break;
			}
		}
	}
	Sleep(2000);
	while(true){
		system(&quot;cls&quot;);
		if(!beta){
			cout&lt;&lt;&quot;战争 7.5.7\n&quot;;
			cout&lt;&lt;&quot;1 攻略\n&quot;;
			cout&lt;&lt;&quot;2 各世界属性\n&quot;;
			cout&lt;&lt;&quot;3 造物主模式\n&quot;;
			cout&lt;&lt;&quot;4 生存模式\n&quot;;
			cout&lt;&lt;&quot;5 衰竭模式\n&quot;;
			cout&lt;&lt;&quot;6 普通模式\n&quot;;
		}else{
			cout&lt;&lt;&quot;战争-beta 1.2.1\n&quot;;//beta模式版本号-6,-3,-6
			cout&lt;&lt;&quot;开始\n&quot;;
		}
		ch=getch();
		if(beta){
			system(&quot;cls&quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		if(!beta&amp;&amp;ch=='1'){
			cout&lt;&lt;char(7);
			cout&lt;&lt;&quot;首先，你可以一直按0大约10次，攒到大约200\n&quot;;
			cout&lt;&lt;&quot;然后，你可以建一层护盾和一个哨兵塔，用来进攻\n&quot;;
			cout&lt;&lt;&quot;接着，继续攒钱，建高射炮来防御坦克及飞机\n&quot;;
			cout&lt;&lt;&quot;最后，只需要在建筑有破损时重建就行了\n&quot;;
			getch();
		}
		else if(!beta&amp;&amp;ch=='2'){
			system(&quot;cls&quot;);
			cout&lt;&lt;&quot;造物主模式初始资源很多\n&quot;;
			cout&lt;&lt;&quot;生存模式资源中等\n&quot;;
			cout&lt;&lt;&quot;衰竭模式资源匮乏，每回合我方扣固定的100血量\n&quot;;
			Sleep(5000);
		}
		else if(!beta&amp;&amp;ch=='3'){
			system(&quot;cls&quot;);
			g=10000;
			jkl=500;
			e1=100000;
			hd=10;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;&amp;ch=='4'){
			system(&quot;cls&quot;);
			g=1000;
			e1=100000;
			hd=5;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;&amp;ch=='5'){
			system(&quot;cls&quot;);
			e=100;
			break;
		}
		else if(!beta&amp;&amp;ch=='@'){
			cout&lt;&lt;char(7)&lt;&lt;char(7)&lt;&lt;char(7)&lt;&lt;char(7);
			cout&lt;&lt;&quot;此版本已上传至永远的CC的博客\n&quot;;
			Sleep(1500);
		}
		else if(!beta&amp;&amp;ch=='6'){
			system(&quot;cls&quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		else cout&lt;&lt;&quot;不要乱输\n&quot;,Sleep(1500);
	}
	system(&quot;cls&quot;);
	if(ssss!=&quot;test&quot;){
		cout&lt;&lt;&quot;加载中...&quot;;
		cout&lt;&lt;endl;
		srand(time(0));
		xx=rand()%int(rand?12:11);
		switch(xx){
			case 0:cout&lt;&lt;&quot;高射炮不仅可以打飞机，把它压下来也可以打地面敌人！&quot;;break;
			case 1:cout&lt;&lt;&quot;迫击炮不仅可以打小兵，还能打敌方基地！&quot;;break;
			case 2:cout&lt;&lt;&quot;小兵打敌方基地的伤害十分可观。&quot;;break;
			case 3:cout&lt;&lt;&quot;导弹可以直接打对方的基地！&quot;;break;
			case 4:cout&lt;&lt;&quot;千万别让小兵接近你的基地，你的建筑十分危险！&quot;;break;
			case 5:cout&lt;&lt;&quot;激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！&quot;;break;
			case 6:cout&lt;&lt;&quot;护盾可以抵挡敌方的一次远程进攻哦！&quot;;break;
			case 7:cout&lt;&lt;&quot;克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用&quot;;break;
			case 8:cout&lt;&lt;&quot;岩石地雷可以在五回合后炸死敌方所有小兵哦！&quot;;break;
			case 9:cout&lt;&lt;&quot;晶坷垃是一种新型货币，不可与金币互换。&quot;;break;
			case 10:cout&lt;&lt;&quot;头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。&quot;;break;
			case 11:cout&lt;&lt;&quot;歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。&quot;;break;
		}
		cout&lt;&lt;'\n';
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(1500,200);
		for(i=0;i&lt;=14;i++) cout&lt;&lt;'&lt;',Sleep(100);
		Beep(2000,1000);
		cout&lt;&lt;&quot; 100%&quot;;
		Sleep(1500);
		system(&quot;cls&quot;);
	}else
	{
		cout&lt;&lt;&quot;ji guang pao (ji fang):&quot;;
		cin&gt;&gt;jg;
		cout&lt;&lt;&quot;di fang gong ji li:&quot;;
		cin&gt;&gt;e;
	}
	//system(&quot;taskkill -f -im f_bgm.exe&quot;);
	//system(&quot;start bgm.exe&quot;);
	system(&quot;cls&quot;);
	while(o1&gt;0&amp;&amp;e1&gt;0&amp;&amp;(sssss==&quot;16391639&quot;||ch=='3'||ch=='2'||g&lt;=100000&amp;&amp;o1&lt;=300000)){
		int ttt=o2;
		int fff=e2;
		o1-=e;
		int last_hp=o1;
		int last_hpe=e1;
		jkl++;
		jkl+=jkl_kc;
		water++;
		xs(ch);
		d=' ';
		srand(time(NULL));
		for(i=1;i&lt;=1+int(beta);i++){
			l=rand()%30+1;
			if(zx!=0){
				zx--;
				l=12;
			}
			if(l&gt;=0&amp;&amp;l&lt;=1){
				sl=rand()%20+1;
				cout&lt;&lt;sl&lt;&lt;&quot;个小兵出现了\n&quot;;
				e2+=sl;
			}
			if(l&gt;=2&amp;&amp;l&lt;=3){
				if(hd==0){
					o1-=100;
					cout&lt;&lt;&quot;一颗导弹在空中画出了一道完美的弧线\n&quot;;
				}
				else{
					hd--;
					cout&lt;&lt;&quot;一颗导弹炸毁了一层护盾\n&quot;;
				}
			}
			if(l&gt;=4&amp;&amp;l&lt;=5){
				if(o2==0)
					if(tk!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&quot;;
						tk--;
					}
					else if(hd!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁了一层护盾\n&quot;;
						hd--;
					}
					else{
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&quot;;
						o1-=80;
					}
				else{
					o2-=40;
					if(o2&lt;0) o2=0;
					cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&quot;;
				}
			}
			if(l&gt;=6&amp;&amp;l&lt;=7){
				cout&lt;&lt;&quot;一块巨石忽忽悠悠地飞来\n&quot;;
				o2-=35;
				if(o2&lt;0) o2=0;
			}
			if(l&gt;=8&amp;&amp;l&lt;=9){
				cout&lt;&lt;&quot;一颗狙击枪子弹射来，&quot;;
				if(pj!=0){
					cout&lt;&lt;&quot;一门迫击炮炸了\n&quot;;
					pj--;
				}
				else if(jg!=0){
					cout&lt;&lt;&quot;一门激光炮炸了\n&quot;;
					jg--;
				}
				else if(ts!=0){
					cout&lt;&lt;&quot;一门投石机炸了\n&quot;;
					ts--;
				}
				else if(bt!=0){
					cout&lt;&lt;&quot;一座哨兵塔炸了\n&quot;;
					bt--;
				}
				else if(hd!=0){
					cout&lt;&lt;&quot;一层护盾炸了\n&quot;;
					hd--;
				}
				else{
					cout&lt;&lt;&quot;扣血150点\n&quot;;
					o1-=150;
				}
			}
			if(l&gt;=10&amp;&amp;l&lt;=10){
				srand(time(NULL));
				sl=rand()%3+1;
				if(sl==3) sl=2;
				else sl=1;
				cout&lt;&lt;sl&lt;&lt;&quot;辆坦克轰然出现\n&quot;;
				tke+=sl;
			}
			if(l&gt;=11&amp;&amp;l&lt;=11){
				if(beta){
					cout&lt;&lt;&quot;咻！一架歼击机穿过云层\n&quot;;
					jjje++;
				}else cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
			}
			if(l&gt;=13&amp;&amp;l&lt;=13){
				cout&lt;&lt;&quot;敌方建造了一个护盾\n&quot;;
				hde++;
			}
			if(l&gt;=14&amp;&amp;l&lt;=15){
				if(fj!=0){
					cout&lt;&lt;&quot;高射炮向天空扫去，一架飞机掉了下来\n&quot;;
					fj--;
				}
				else{
					if(tk!=0){
						cout&lt;&lt;&quot;高射炮向地面扫去，炸毁一辆坦克\n&quot;;
						tk--;
					}
					else{
						if(o2!=0){
							cout&lt;&lt;&quot;高射炮向地面扫去，炸死一个小兵\n&quot;;
							o2--;
						}
						else cout&lt;&lt;&quot;高射炮没有目标\n&quot;;
					}
				}
			}
			if(l&gt;=16&amp;&amp;l&lt;=16){
				cout&lt;&lt;&quot;一架飞机出现了\n&quot;;
				fje++;
			}
			if(l&gt;=17&amp;&amp;l&lt;=18){
				cout&lt;&lt;&quot;瘟疫发生了\n&quot;;
				o2/=2;
			}
			if(l&gt;=19&amp;&amp;l&lt;=19){
				if(fj&gt;=2){
					cout&lt;&lt;&quot;一束激光射向天空，两架飞机掉了下来\n&quot;;
					fj-=2;
				}
				else{
					if(fj==1){
						cout&lt;&lt;&quot;一束激光射向天空，一架飞机掉了下来\n&quot;;
						fj--;
					}
					else if(tk!=0&amp;&amp;o2!=0){
						cout&lt;&lt;&quot;一束激光平射而来，击毁了&quot;&lt;&lt;min(3,tk)&lt;&lt;&quot;辆坦克，炸死&quot;&lt;&lt;min(20,o2)&lt;&lt;&quot;个小兵\n&quot;;
						tk-=min(3,tk);
						o2-=min(20,o2);
					}
					else{
						if(tk!=0){
							cout&lt;&lt;&quot;一束激光平射而来，击毁了&quot;&lt;&lt;min(3,tk)&lt;&lt;&quot;辆坦克\n&quot;;
							tk-=min(3,tk);
						}
						else{
							if(o2!=0){
								cout&lt;&lt;&quot;一束激光平射而来，炸死&quot;&lt;&lt;min(20,o2)&lt;&lt;&quot;个小兵\n&quot;;
								o2-=min(20,o2);
							}
							else if(hd!=0){
								cout&lt;&lt;&quot;一束激光平射而来，一层护盾炸了\n&quot;;
								hd--;
							}
							else{
								cout&lt;&lt;&quot;一束激光向你方平射而来\n&quot;;
								o1-=100;
							}
						}
					}
				}
			}
			if(l&lt;=20&amp;&amp;l&gt;=20){
				cout&lt;&lt;&quot;对方使用了神秘的法术，小兵数量变成了两倍\n&quot;;
				e2*=2;
			}
			if(l&lt;=21&amp;&amp;l&gt;=21){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
				jde++;
			}
			if(l&gt;=12&amp;&amp;l&lt;=12||l&gt;=22&amp;&amp;l&lt;=23||l&gt;=28&amp;&amp;l&lt;=30){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
			}
			if(l&gt;=24&amp;&amp;l&lt;=25){
				cout&lt;&lt;&quot;敌方建造了一个屏障\n&quot;;
				pze++;
			}
			if(l&gt;=26&amp;&amp;l&lt;=26){
				cout&lt;&lt;&quot;敌方建造了一个量子屏障\n&quot;;
				lzpze++;
			}
			if(l&gt;=27&amp;&amp;l&lt;=27){
				cout&lt;&lt;&quot;这轮什么也没出现\n&quot;;
				dle++;
			}
			if(i==1) Sleep(2000);
		}
		dd=rand()%(beta?40:30)+1+jk*5;
		cout&lt;&lt;&quot;你得到了&quot;&lt;&lt;dd&lt;&lt;&quot;个金币\n&quot;;
		g+=dd;
		Sleep(2000);
		system(&quot;cls&quot;);
		while(d!='0'){
			xs(ch);
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;1   派出小兵 3$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             2   导弹 50$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;3   迫击炮 120$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             4   投石机 100$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;5   坦克 60$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             6   哨兵塔 100$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;7   高射炮 120$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             8   飞机 80$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;9   瘟疫 50$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             a   激光炮 180$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;b   护盾 80$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             c   克隆法术 80$/1&quot;;
			if(ch=='3') cout&lt;&lt;&quot;禁用\n&quot;;
			else cout&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;d   金矿开采机 50$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             e   间谍 80$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;f   诈降书 150$/1&quot;;
			if(zx!=0) cout&lt;&lt;&quot;禁用&quot;;
			else cout&lt;&lt;&quot;&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             g   屏障 2$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;h   量子屏障 10$/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             i   岩石地雷 50$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;j   晶坷垃开采器 5G/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;            k   头铁少年 5G/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;l   钻地少年 5G/1&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;             m   回血药水(回250) 10G+20$/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;n   回血器(一次回50) 30G+60$/1&quot;&lt;&lt;&quot;\n&quot;;
			if(beta) cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;o   歼击机 120$+25G/1&quot;&lt;&lt;&quot;\n&quot;;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;p   打怪(实在不行去刷)&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;q   查看注释&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;r   开宝箱&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;s   查看成就&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;t   查看如何获得成就&quot;&lt;&lt;endl;
			cout&lt;&lt;left&lt;&lt;setw(20)&lt;&lt;&quot;u   抽奖&quot;&lt;&lt;endl;
			if(beta) cout&lt;&lt;&quot;*   升级主塔 100$+20G/1\n&quot;;
			cout&lt;&lt;&quot;\\   关闭\n&quot;;
			cout&lt;&lt;&quot;#   礼包码(hehe为官方礼包码)\n&quot;;
			cout&lt;&lt;&quot;0   继续&quot;;
			d=getch();
			if(d=='u'){
				cj();
			}
			if(d=='t'){
				system(&quot;cls&quot;);
				printf(&quot;买到终极宝箱（终极奥义）\n&quot;);
				printf(&quot;买宝箱20次  （奉献精神）\n&quot;);
				printf(&quot;杀死20个怪  （怪物猎人）\n&quot;);
				printf(&quot;买回血器5个 （回血大师）\n&quot;);
				printf(&quot;打死十级怪物（打怪大师）\n&quot;);
				Sleep(5000);
			}
			if(d=='s'){
				system(&quot;cls&quot;);
				if(zjay) printf(&quot;终极奥义\n&quot;);
				if(fxjs) printf(&quot;奉献精神\n&quot;);
				if(gwlr) printf(&quot;怪物猎人\n&quot;);
				if(hxds) printf(&quot;回血大师\n&quot;);
				if(dgds) printf(&quot;打怪大师\n&quot;);
				Sleep(5000);
			}
			if(d=='r'){
				kaibx();
			}
			if(d=='q'){
				system(&quot;cls&quot;);
				printf(&quot;因打怪，宝箱模板没有时间了，所以做得简陋一点\n&quot;);
				printf(&quot;下个版本升级的打怪\n&quot;);
				Sleep(5000);
			}
			if(d=='p'){
				bdaguai();
			}
			if(d=='#'){
				system(&quot;cls&quot;);
				cout&lt;&lt;&quot;请输入礼包码形如 *** 及你名字的缩写的小写形式\n&quot;;
				cout&lt;&lt;&quot;请输入:&quot;;
				string str;
				cin&gt;&gt;str;
				if(str==ssss)
				  g+=100,jkl+=100,e1+=100;
				cout&lt;&lt;&quot;正在处理...&quot;;
				Sleep(1500);
				system(&quot;cls&quot;);
				continue;
			}
			if(d=='\\'){
				system(&quot;cls&quot;);
				return;
			}
			if(beta&amp;&amp;d=='*'){
				if(g&gt;=100&amp;&amp;jkl&gt;=20){
					g-=100;
					jkl-=20;
					Lv++;
					o1_max+=500;
					o1+=500;
					lzpz+=10;
				}
			}
			if(d=='1'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*3&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				o2+=s;
				g-=s*3;
				system(&quot;cls&quot;);
			}
			if(d=='2'){
				if(g&gt;=50){
					g-=50;
					if(hde!=0){
						e1-=100;
					}
					else{
						hde--;
					}
				}
			}
			if(d=='3'){
				if(g&gt;=120){
					g-=120;
					pj++;
				}
			}
			if(d=='4'){
				if(g&gt;=100){
					g-=100;
					ts++;
				}
			}
			if(d=='5'){
				if(g&gt;=60){
					g-=60;
					tk++;
				}
			}
			if(d=='6'){
				if(g&gt;=100){
					g-=100;
					bt++;
				}
			}
			if(d=='7'){
				if(g&gt;=120){
					g-=120;
					gs++;
				}
			}
			if(d=='8'){
				if(g&gt;=80){
					g-=80;
					fj++;
				}
			}
			if(d=='9'){
				if(g&gt;=50){
					g-=50;
					e2/=2;
				}
			}
			if(d=='a'){
				if(g&gt;=180){
					g-=180;
					jg++;
				}
			}
			if(d=='b'){
				if(g&gt;=80){
					g-=80;
					hd++;
				}
			}
			if(d=='c'){
				if(g&gt;=80&amp;&amp;ch!='3'){
					g-=80;
					system(&quot;cls&quot;);
					cout&lt;&lt;&quot;一抹神秘的光辉映在天空中，小兵变成了原来的两倍\n&quot;;
					Sleep(2500);
					o2*=2;
				}
			}
			if(d=='d'){
				if(g&gt;=50){
					g-=50;
					jk++;
				}
			}
			if(d=='e'){
				if(g&gt;=80){
					g-=80;
					jd++;
				}
			}
			if(d=='f'){
				if(g&gt;=150&amp;&amp;zx==0){
					g-=150;
					zx+=5;
				}
			}
			if(d=='g'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*2&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				pz+=s;
				g-=s*2;
				system(&quot;cls&quot;);
			}
			if(d=='h'){
				system(&quot;cls&quot;);
				xs(ch);
				cout&lt;&lt;&quot;数量:&quot;;
				cin&gt;&gt;s;
				while(s*10&gt;g){
					system(&quot;cls&quot;);
					xs(ch);
					cout&lt;&lt;&quot;数量:&quot;;
					cin&gt;&gt;s;
				}
				lzpz+=s;
				g-=s*10;
				system(&quot;cls&quot;);
			}
			if(d=='i'){
				if(g&gt;=50){
					g-=50;
					dl+=5;
				}
			}
			if(d=='j'){
				if(jkl&gt;=5){
					jkl-=5;
					jkl_kc++;
				}
			}
			if(d=='k'){
				if(jkl&gt;=5){
					jkl-=5;
					tt++;
				}
			}
			if(d=='l'){
				if(jkl&gt;=5){
					jkl-=5;
					zd++;
				}
			}
			if(d=='m'){
				if(jkl&gt;=10&amp;&amp;g&gt;=20){
					jkl-=10;
					g-=20;
					o1=min(o1_max,o1+250);
				}
			}
			if(d=='n'){
				if(jkl&gt;=30&amp;&amp;g&gt;=60){
					jkl-=30;
					g-=60;
					reblood++;
					hxcs++;
					if(hxcs&gt;=5&amp;&amp;hxds!=1){
						hxds=1;
						system(&quot;cls&quot;);
						printf(&quot;恭喜你取得了回血大师的成就！！！\n&quot;);
						Sleep(5000);
						printf(&quot;奖励10晶坷垃,100金币&quot;);
						g+=100;
						jkl+=10;
						Sleep(5000);
					}
				}
			}
			if(d=='o'){
				if(g&gt;=120&amp;&amp;jkl&gt;=25){
					g-=120;
					jkl-=25;
					jjj++;
				}
			}
			system(&quot;cls&quot;);
		}
		if(dl!=0){
			if(dl%5!=0)
			  dl-=(dl/5+1);else
			  dl-=dl/5;
			if(dl%5==0){
				cout&lt;&lt;&quot;一声惊天巨响，敌方小兵化为骨灰\n&quot;;
				e2=0;
			}
		}
		if(dle!=0){
			if(dle%5!=0)
			  dle-=(dle/5+1);else
			  dle-=dle/5;
			if(dle%5==0){
				cout&lt;&lt;&quot;一声惊天巨响，我方小兵化为骨灰\n&quot;;
				o2=0;
			}
		}
		if(jd!=0){
			if(e2!=0){
				cout&lt;&lt;&quot;我方间谍使敌方&quot;&lt;&lt;min(jd,e2)&lt;&lt;&quot;个小兵叛变了\n&quot;;
				e2-=min(jd,e2);
				o2+=min(jd,e2);
			}
			else{
				cout&lt;&lt;&quot;我方间谍被发现！\n&quot;;
				jd=0;
			}
		}
		if(jde!=0){
			if(o2!=0){
				o2-=min(jde,o2);
				e2+=min(jde,o2);
			}
			else{
				cout&lt;&lt;&quot;敌方间谍被发现！\n&quot;;
				jde=0;
			}
		}
		if(tt!=0){
			if(hde!=0){
				hde-=min(min(tt,hde),jkl);
				jkl-=min(min(tt,hde),jkl);
			}
			if(hde&lt;=0) hde=0;
		}
		if(zd!=0){
			if(e2!=0){
				e2-=min(min(e2/10,zd),jkl);
				jkl-=min(min(e2/10,zd),jkl);
			}
			if(e2&lt;=0) e2=0;
		}
		for(i=1;i&lt;=pj;i++)
			if(e2==0)
				if(tke!=0){
					cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&quot;;
					tke--;
				}
				else{
					if(hde!=0){
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，击毁一层护盾\n&quot;;
						hde--;
					}
					else{
						cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向敌方飞去\n&quot;;
						e1-=80;
					}
				}
			else{
				if(e2&gt;=40){
					g+=80;
					e2-=40;
				}
				else{
					g+=e2*2;
					e2=0;
				}
				if(e2&lt;0) e2=0;
				cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&quot;;
			}
		for(i=1;i&lt;=ts;i++){
			if(e2&gt;=35){
				e2-=35;
				g+=70;
			}
			else{
				g+=e2*2;
				e2=0;
			}
			cout&lt;&lt;&quot;一块巨石忽忽悠悠地飞去\n&quot;;
		}
		for(i=1;i&lt;=bt;i++){
			cout&lt;&lt;&quot;5个小兵慢悠悠地从哨兵塔里走出来\n&quot;;
			o2+=5;
		}
		for(i=1;i&lt;=gs;i++){
			if(fje!=0){
				cout&lt;&lt;&quot;高射炮向天空扫去，一架飞机掉了下来\n&quot;;
				fje--;
			}
			else{
				if(tke!=0){
					cout&lt;&lt;&quot;高射炮向地面扫去，炸毁一辆坦克\n&quot;;
					tke--;
				}
				else{
					if(e2!=0){
						cout&lt;&lt;&quot;高射炮向地面扫去，炸死一个小兵\n&quot;;
						e2--;
					}
					else cout&lt;&lt;&quot;高射炮没有目标\n&quot;;
				}
			}
		}
		for(i=1;i&lt;=jg;i++)
			if(fje&gt;=2){
				cout&lt;&lt;&quot;一束激光射向天空，两架飞机掉了下来\n&quot;;
				fje-=2;
			}
			else{
				if(fje==1){
					cout&lt;&lt;&quot;一束激光射向天空，一架飞机掉了下来\n&quot;;
					fje--;
				}
				else if(tke!=0&amp;&amp;e2!=0){
					cout&lt;&lt;&quot;一束激光平射出去，击毁了&quot;&lt;&lt;min(3,tke)&lt;&lt;&quot;辆坦克，炸死&quot;&lt;&lt;min(15,e2)&lt;&lt;&quot;个小兵\n&quot;;
					tke-=min(3,tke);
					e2-=min(15,e2);
				}
				else{
					if(tke!=0){
						cout&lt;&lt;&quot;一束激光平射出去，击毁了&quot;&lt;&lt;min(3,tke)&lt;&lt;&quot;辆坦克\n&quot;;
						tke-=min(3,tke);
					}
					else{
						if(e2!=0){
							cout&lt;&lt;&quot;一束激光平射出去，炸死&quot;&lt;&lt;min(15,e2)&lt;&lt;&quot;个小兵\n&quot;;
							e2-=min(15,e2);
						}
						else{
							if(hde!=0){
								cout&lt;&lt;&quot;一束激光平射出去，击毁一层护盾\n&quot;;
								hde--;
							}
							else{
								cout&lt;&lt;&quot;一束激光向敌方平射出去\n&quot;;
								e1-=150;
							}

						}
					}
				}
			}
		if(fj!=0&amp;&amp;fje!=0){
			fk=fj&lt;fje?fj:fje;
			fj-=fk;fje-=fk;
			cout&lt;&lt;&quot;双方都有&quot;&lt;&lt;fk&lt;&lt;&quot;架飞机从空中落下来了\n&quot;;
		}
		for(i=1;i&lt;=fj;i++){
			if(hde!=0){
				cout&lt;&lt;&quot;我方飞机击毁一层护盾\n&quot;;
				hde--;
			}
			else{
				cout&lt;&lt;&quot;我方飞机俯冲轰炸！\n&quot;;
				e1-=150;
			}
		}
		for(i=1;i&lt;=fje;i++){
			if(hd!=0){
				cout&lt;&lt;&quot;敌方飞机击毁我方一层护盾\n&quot;;
				hd--;
			}
			else{
				cout&lt;&lt;&quot;敌方飞机俯冲轰炸！\n&quot;;
				o1-=150;
			}
		}
		if(jjj!=0&amp;&amp;jjje!=0){
			fk=jjj&lt;jjje?jjj:jjje;
			jjj-=fk;jjje-=fk;
			cout&lt;&lt;&quot;双方都有&quot;&lt;&lt;fk&lt;&lt;&quot;架歼击机从空中落下来了\n&quot;;
		}
		for(i=1;i&lt;=jjj;i++){
			if(hde!=0){
				cout&lt;&lt;&quot;我方歼击机击毁一层护盾\n&quot;;
				hde--;
			}
			else{
				cout&lt;&lt;&quot;我方歼击机俯冲轰炸！\n&quot;;
				e1-=200;
			}
		}
		for(i=1;i&lt;=jjje;i++){
			if(hd!=0){
				cout&lt;&lt;&quot;敌方歼击机击毁我方一层护盾\n&quot;;
				hd--;
			}
			else{
				cout&lt;&lt;&quot;敌方歼击机俯冲轰炸！\n&quot;;
				o1-=200;
			}
		}
		if(tk!=0&amp;&amp;tke!=0){
			tkk=tk&lt;tke?tk:tke;
			cout&lt;&lt;&quot;坦克开炮了，双方都有&quot;&lt;&lt;tkk&lt;&lt;&quot;门坦克损毁了\n&quot;;
			tk-=tkk;tke-=tkk;
		}
		if(o2!=0&amp;&amp;tke*20&gt;o2){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;o2&lt;&lt;&quot;个小兵死去了\n&quot;;
			if(o2/20!=0)
				cout&lt;&lt;o2/20&lt;&lt;&quot;门坦克损毁了\n&quot;;
			o2=0;tke-=o2/20;
		}
		if(tke!=0&amp;&amp;o2&gt;=tke*20){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;tke*20&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tke*60;
			cout&lt;&lt;tke&lt;&lt;&quot;门坦克损毁了\n&quot;;
			o2-=tke*20;tke=0;
		}
		if(o2!=0&amp;&amp;e2!=0)
			cout&lt;&lt;&quot;有小兵倒下去了\n&quot;;
		else cout&lt;&lt;&quot;没有小兵倒下\n&quot;;
		if(e2!=0&amp;&amp;tk*20&gt;e2){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;e2&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tk*60;
			if(e2/20!=0)
				cout&lt;&lt;e2/20&lt;&lt;&quot;门坦克损毁了\n&quot;;
			e2=0;tk-=e2/20;
		}
		if(tk!=0&amp;&amp;e2&gt;=tk*20){
			cout&lt;&lt;&quot;坦克开炮了，&quot;&lt;&lt;tk*20&lt;&lt;&quot;个小兵死去了\n&quot;;
			g+=tk*60;
			cout&lt;&lt;tk&lt;&lt;&quot;门坦克损毁了\n&quot;;
			e2-=tk*20;tk=0;
		}
		if(ttt-o2&gt;50){
			o2-=(ttt-o2)/10;
			cout&lt;&lt;&quot;我方有&quot;&lt;&lt;(ttt-o2)/10&lt;&lt;&quot;个小兵逃走了&quot;;
		}
		if(fff-e2&gt;50){
			e2-=(fff-e2)/10;
			cout&lt;&lt;&quot;敌方有&quot;&lt;&lt;(fff-e2)/10&lt;&lt;&quot;个小兵逃走了&quot;;
		}
		if(o2&gt;e2){
			g+=e2*2;
			o2-=e2;
			e2=0;
		}
		else{
			g+=o2*2;
			e2-=o2;
			o2=0;
		}
		if(o2!=0){
			e1-=o2*5;
			cout&lt;&lt;&quot;我方小兵围殴敌方，扣血&quot;&lt;&lt;o2*5&lt;&lt;&quot;点\n&quot;;
		}
		if(tk!=0){
			e1-=tk*20;
			cout&lt;&lt;&quot;我方坦克围殴敌方，扣血&quot;&lt;&lt;tk*20&lt;&lt;&quot;点\n&quot;;
		}
		if(e2!=0){
			k=e2;
			if(pj*30&gt;k){
				if(k/30!=0)
					cout&lt;&lt;k/30&lt;&lt;&quot;门迫击炮损坏了\n&quot;;
				pj-=k/30;
			}
			else{
				if(pj!=0)
					cout&lt;&lt;pj&lt;&lt;&quot;门迫击炮损坏了\n&quot;;
				k-=pj*30;pj=0;
				if(ts*25&gt;k){
					if(k/25!=0)
						cout&lt;&lt;k/25&lt;&lt;&quot;门投石机损坏了\n&quot;;
					ts-=k/25;
				}
				else{
					if(ts!=0)
						cout&lt;&lt;ts&lt;&lt;&quot;门投石机损坏了\n&quot;;
					k-=ts*25;ts=0;
					if(jg*35&gt;k){
						if(k/35!=0)
							cout&lt;&lt;k/35&lt;&lt;&quot;架激光炮损坏了\n&quot;;
						jg-=k/35;
					}
					else{
						if(jg!=0)
							cout&lt;&lt;jg&lt;&lt;&quot;架激光炮损坏了\n&quot;;
						k-=jg*35;jg=0;
						if(bt*20&gt;k){
							if(k/20!=0)
								cout&lt;&lt;k/20&lt;&lt;&quot;座哨兵塔损坏了\n&quot;;
							bt-=k/20;
						}
						else{
							if(bt!=0)
								cout&lt;&lt;bt&lt;&lt;&quot;座哨兵塔损坏了\n&quot;;
							k-=bt*20;bt=0;
							if(k!=0){
								cout&lt;&lt;&quot;敌方小兵围殴我方，扣血&quot;&lt;&lt;k*5&lt;&lt;&quot;点\n&quot;;
								o1-=k*5;
							}
						}
					}
				}
			}
		}
		for(i=1;i&lt;=tke;i++){
			if(pj!=0){
				pj--;
				cout&lt;&lt;&quot;1门迫击炮损坏了\n&quot;;
			}
			else if(jg!=0){
				jg--;
				cout&lt;&lt;&quot;1架激光炮损坏了\n&quot;;
			}
			else if(ts!=0){
				ts--;
				cout&lt;&lt;&quot;1门投石机损坏了\n&quot;;
			}
			else if(bt!=0){
				bt--;
				cout&lt;&lt;&quot;1座哨兵塔损坏了\n&quot;;
			}
			else{
				o1-=(tke-i+1)*100;
				cout&lt;&lt;&quot;敌方坦克围殴我方，扣血&quot;&lt;&lt;(tke-i+1)*100&lt;&lt;&quot;点\n&quot;;
				i=tke;
			}
		}
		if(o1&lt;last_hp) o1+=min(lzpz,last_hp-o1);
		if(o1&lt;last_hp){
			o1+=min(pz,last_hp-o1);
			pz-=min(pz,last_hp-o1);
		}
		if(e1&lt;last_hpe) e1+=min(lzpze,last_hpe-e1);
		if(e1&lt;last_hpe){
			e1+=min(pze,last_hpe-e1);
			pze-=min(pze,last_hpe-e1);
		}
		cout&lt;&lt;&quot;咕嘟嘟,+&quot;&lt;&lt;reblood*50&lt;&lt;&quot;血\n&quot;;
		o1=min(o1_max,o1+reblood*50);
		Sleep(3000);
		system(&quot;cls&quot;);
		if(ch=='3') ++iii;
	}
	if(g&gt;10000||o1&gt;10000) bg();
	if(o1&lt;=0){
		if(e1&gt;500&amp;&amp;e1&lt;1500) cout&lt;&lt;&quot;城池被攻破，人类的最后一道防线破碎，人类沦为了宇宙中的一片尘埃。\n&quot;;
		if(e1&gt;=1500) cout&lt;&lt;&quot;你已经很努力了，但敌方太强，你无法抗衡\n人类不堪的淹没在了历史的长河中。\n&quot;;
		if(e1&lt;=500) cout&lt;&lt;&quot;你的各个方面都很强，但在最后无法力挽狂澜，才使人类文明灭亡。\n&quot;;
	}
	else{
		if(o1&gt;500&amp;&amp;o1&lt;1500) cout&lt;&lt;&quot;你靠自己的顽强决心守住了城池，救回了人类文明。\n&quot;;
		if(o1&lt;=500) cout&lt;&lt;&quot;你在最后的紧要关头击退了人类异种，挽救了人类文明。\n&quot;;
		if(o1&gt;=1500) cout&lt;&lt;&quot;你以自己的高超指挥能力击退了人类异种，拯救了整个人类！！！\n\n&quot;;
	}
	Sleep(3000);
	system(&quot;cls&quot;);
	if(ssss!=&quot;16391639&quot;){
		system(&quot;cls&quot;);
		cout&lt;&lt;&quot;若有bug,加入需求及新想法,请发表\n&quot;;
		cout&lt;&lt;&quot;goodbye&quot;&lt;&lt;endl;
		Sleep(2500);
		return;
	}
	//system(&quot;taskkill -f -im bgm.exe&quot;);
	//system(&quot;cls&quot;);
	//system(&quot;start second.exe&quot;);
	//Sleep(5000);
	//system(&quot;start third.exe&quot;);
	//system(&quot;pause&quot;);
	return;
}
void bg(){
	system(&quot;cls&quot;);
	cout&lt;&lt;&quot;小朋友想走不正当途径是不好的\n&quot;;
	Sleep(3000);
	xs(ch);
	for(i=1;i&lt;=10000;i++)
		 cout&lt;&lt;&quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&quot;;
	cout&lt;&lt;&quot;你死了！&quot;;
}
int main(){
	//system(&quot;start f_bgm.exe&quot;);
	//system(&quot;start first.exe&quot;);
	//system(&quot;cls&quot;);
	std::srand(time(0));
	printf(&quot;加载中...\n&quot;);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=12;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(1500,200);
	for(i=0;i&lt;=14;i++) cout&lt;&lt;'&lt;',Sleep(100);
	Beep(2000,1000);
	cout&lt;&lt;&quot; 100%&quot;;
	Sleep(1500);
	system(&quot;cls&quot;);
	cout&lt;&lt;&quot;黑_白(永远的CC) 段建泽出品\n&quot;;
	cout&lt;&lt;&quot;请输入姓名\n&quot;;
	cout&lt;&lt;&quot;格式为***，前后没有空格，全部为小写\n&quot;;
	cin&gt;&gt;ssss;
	system(&quot;cls&quot;),aa(ssss);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快读快写是什么？怎么写？可以用来卡常吗？]]></title>
        <id>https://yydcc-blog.github.io/post/kuai-du-kuai-xie-shi-shi-me-zen-me-xie-ke-yi-yong-lai-qia-chang-ma/</id>
        <link href="https://yydcc-blog.github.io/post/kuai-du-kuai-xie-shi-shi-me-zen-me-xie-ke-yi-yong-lai-qia-chang-ma/">
        </link>
        <updated>2022-01-28T07:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-0前言">Part 0：前言</h1>
<p>突发奇想，来介绍快读快写。</p>
<p>希望大家喜欢！😉</p>
<h1 id="part-1快读快写是什么">Part 1：快读快写是什么？</h1>
<p>因为<code>getchar()</code>和<code>putchar()</code>很快，所以我们可以利用这个把输入输出的速度提到很快。</p>
<h1 id="part-2怎么写">Part 2：怎么写？</h1>
<h2 id="part-21快读">Part 2.1：快读</h2>
<h3 id="写法">写法：</h3>
<p>首先定义函数<code>int read()</code></p>
<p>既然是读入整数，那么就要把多余的空格和负数考虑到：</p>
<pre><code class="language-cpp">int f=1;
char ch=getchar();
while(ch&lt;'0'||ch&gt;'9'){
	if(ch=='-')
	f=-1;
	ch=getchar();
}
</code></pre>
<p>然后边输入边加在一个变量上：</p>
<pre><code class="language-cpp">int s=0;
while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
	s=s*10+ch-'0';
	ch=getchar();
}
</code></pre>
<p>这里还不够快，把<code>s*10</code>改成位运算：<code>(s&lt;&lt;1+s&lt;&lt;3)</code>。</p>
<p>最后输出（别忘把负数的情况考虑上）：<code>return s*f</code>。</p>
<p>完整代码：</p>
<pre><code class="language-cpp">int read(){
	int s=0,f=1;
	char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
		s=(s&lt;&lt;1+s&lt;&lt;3)+ch-'0';
		ch=getchar();
	}
	return s*f;
}
</code></pre>
<h3 id="解析">解析：</h3>
<ul>
<li>定义函数和变量。</li>
<li><code>while()</code>输入直到<code>-</code>或数字，记录负数的情况。</li>
<li><code>while()</code>边输入边累加。</li>
<li><code>return</code>返回值。</li>
</ul>
<h2 id="part-22快写">Part 2.2：快写</h2>
<p>递归写法，比较简单。</p>
<p>完整代码：</p>
<pre><code class="language-cpp">void write(int x){
    if(x&lt;0){
    	putchar('-');
		x=-x;
	}
    if(x&gt;9) 
		write(x/10);
    putchar(x%10+'0');
}
</code></pre>
<h1 id="part3可以用来卡常吗">Part3：可以用来卡常吗？</h1>
<p>可以。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用C++玩generals.io]]></title>
        <id>https://yydcc-blog.github.io/post/ru-he-yong-cwan-generalsio/</id>
        <link href="https://yydcc-blog.github.io/post/ru-he-yong-cwan-generalsio/">
        </link>
        <updated>2022-01-26T07:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>源自generals.io</p>
<p>大洋彼岸的服务器体验极差！</p>
<p>使用说明</p>
<p>整合了零人、单人、双人版</p>
<h1 id="单人版通用规则">单人版&amp;&amp;通用规则</h1>
<p>图片：https://www.picb.cc/image/tAJbks和https://www.picb.cc/image/tAJ7Nj</p>
<p>先输入0/1/2，代表游戏人数</p>
<p>然后要输入一个随机数种子（更新：长度可以任意），相同种子（相同编译器？）生成相同地图</p>
<p>地图：X为障碍，黑色背景的数为原有城市，红色为玩家的，蓝色为电脑的，城市和普通地面颜色不同</p>
<p>数字表示：数大于99时只显示最高位和一个字母 （e代表100，k代表1000，w代表10000），数大于99999就显示&quot;ju&quot; （巨）</p>
<p>在屏幕左下角可以看到光标所指的数的精确值（hp）</p>
<p>光标是一个小于号&quot;&lt;&quot;，用方向键控制光标</p>
<p>按下w/s/a/d时，光标的左边那个数（前提是自己的）会随光标移动</p>
<p>按下z，再按w/s/a/d，光标的左边那个数（前提是自己的）的一半会随光标移动</p>
<p>无法移动的情况：遇到障碍/下一个位置上的数不是自己的，且&gt;=自己的数-1</p>
<p>时间以回合（count）为单位，在屏幕左下角</p>
<p>移动光标不算回合，移动数字算，按到空格键视作放弃一回合</p>
<p>城市每回合+2，其余被占领的地面每10回合+1</p>
<p>屏幕左下角的&quot;army&quot;指一方数字和，&quot;land&quot;指一方占领的格子数</p>
<h1 id="零人版">零人版</h1>
<p>两个一样的bfs算法对打</p>
<p>只要观战就可以啦</p>
<p>可以按方向键移动光标，但不能移动任何数</p>
<p>按下空格键进入下一回合</p>
<p>如果想快点看到结果，按f键，之后无法移动光标</p>
<h1 id="双人版">双人版</h1>
<p>红方键盘：(z/x+) w/s/a/d，默认只移动光标，按z移一半<br>
数，按x移全部</p>
<p>蓝方键盘：(n/m+) 方向键，默认只移动光标，按n移一半数，按m移全部</p>
<p>任何一方按空格可以放弃一回合</p>
<p>游戏时间会很漫长</p>
<p>地图有概率出现“封城”，城市也可能分布不公平，换一个种<br>
子重启（继续碰运气）即可</p>
<p>当一方操作结束，光标会移到地图的左上角或右下角，（希望）能方便操作</p>
<p>结束条件：占领所有主塔（最开始的塔再【1】【1】或【n】【n】）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt; 
#include&lt;cstdio&gt; 
#include&lt;fstream&gt; 
#include&lt;algorithm&gt; 
#include&lt;cmath&gt; 
#include&lt;deque&gt; 
#include&lt;vector&gt; 
#include&lt;queue&gt; 
#include&lt;string&gt; 
#include&lt;cstring&gt; 
#include&lt;map&gt; 
#include&lt;stack&gt; 
#include&lt;set&gt; 
#include&lt;windows.h&gt;
#include&lt;conio.h&gt;
#include&lt;ctime&gt;
using namespace std;

const int cA=5;//red城市 
const int cB=3;//blue城市 
const int ca=4;//red地面 
const int cb=1;//blue地面 
const int cC=0;//black原有城市 
const int msize=16;//地图大小 
const int mount=16;//障碍数量 
const int grey=16;//城市数量 
const int pmain=2;//城市hp每回合增加量 
const int lcnt=10;//地面hp增加1所需回合 

char cMap[msize][msize];//大写字母表示城市，小写表示地面，Aa是红，Bb是蓝，C是白，X是障碍 
int hp[msize][msize];
int nCount,sx,sy;//回合累加，和光标的坐标 
bool bVis[msize][msize];//bfs
int dir[4][2]={1,0,-1,0,0,1,0,-1};//bfs

struct dRet//决策信息：位置为(x,y)的数移到(x+dx,y+dy) 
{
	int x;
	int y;
	int dx;
	int dy;
};

struct node//bfs 
{
	int x;
	int y;
	int step;
};

void vInit();//生成地图 
void vMove(int dx,int dy);//移动光标 
//以下5个函数，保证A=='A'||A=='B' 
void vMoveNum(int dx,int dy,char A);
void vMoveNum(int x,int y,int dx,int dy,char A);
void vDiv(int dx,int dy,char A);
void vDecide(char A);
dRet bfs(int x,int y,char A);
void vPlus();//每回合数值增加，计算army和land 
void vChange(int x,int y);//刷新屏幕上指定坐标的数 
void gotoxy(int x,int y);//移动输出的位置 
void color(int t,int b);//设置输出颜色，t为文字色，b为背景色 
void vMain0();
void vMain1();
void vMain2();
void vEnd();//判断游戏结束 

int main()
{
	int p; 
	cout&lt;&lt;&quot;player:&quot;&lt;&lt;endl;
	cin&gt;&gt;p;
	system(&quot;cls&quot;);
	if(p==0) vMain0();
	if(p==1) vMain1();
	if(p==2) vMain2();
	return 0;
}

void vMain0()
{
	int in;
	bool cur=true;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount&lt;&lt;endl;
		if(cur)
		{
			do
			{
				in=getch();
				if(in==224) 
				{
					in=getch();
					if(in==72) vMove(-1,0);
					if(in==80) vMove(1,0);
					if(in==75) vMove(0,-1);
					if(in==77) vMove(0,1);
				}
			}while(in!=' '&amp;&amp;in!='f');
			if(in=='f') cur=false;
		}
		vDecide('A');
		vDecide('B');
		vPlus();
	}
}

void vMain1()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount&lt;&lt;endl;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!='w'&amp;&amp;in!='s'&amp;&amp;in!='a'&amp;&amp;in!='d'&amp;&amp;in!='z'&amp;&amp;in!=' ');
		if(in=='w') vMoveNum(-1,0,'A');
		if(in=='s') vMoveNum(1,0,'A');
		if(in=='a') vMoveNum(0,-1,'A');
		if(in=='d') vMoveNum(0,1,'A');
		if(in=='z')
		{
			in=getch();
			if(in=='w') vDiv(-1,0,'A');
			if(in=='s') vDiv(1,0,'A');
			if(in=='a') vDiv(0,-1,'A');
			if(in=='d') vDiv(0,1,'A');
		}
		vDecide('B');
		vPlus();
	}
}

void vMain2()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&lt;&lt;&quot;count=&quot;&lt;&lt;nCount;
		vMove(-sx,-sy);
		gotoxy(msize+1,0);
		cout&lt;&lt;&quot;red &quot;;
		do
		{
			in=getch();
			if(in=='w') vMove(-1,0);
			if(in=='s') vMove(1,0);
			if(in=='a') vMove(0,-1);
			if(in=='d') vMove(0,1);
		}while(in!='x'&amp;&amp;in!='z'&amp;&amp;in!=' ');
		if(in=='x')
		{
			in=getch();
			if(in=='w') vMoveNum(-1,0,'A');
			if(in=='s') vMoveNum(1,0,'A');
			if(in=='a') vMoveNum(0,-1,'A');
			if(in=='d') vMoveNum(0,1,'A');
		}
		else if(in=='z')
		{
			in=getch();
			if(in=='w') vDiv(-1,0,'A');
			if(in=='s') vDiv(1,0,'A');
			if(in=='a') vDiv(0,-1,'A');
			if(in=='d') vDiv(0,1,'A');
		}
		vEnd();
		////////////////////////////////
		vMove(msize-1-sx,msize-1-sy);
		gotoxy(msize+1,0);
		color(15,0);
		cout&lt;&lt;&quot;blue&quot;;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!='n'&amp;&amp;in!='m'&amp;&amp;in!=' ');
		if(in=='m')
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMoveNum(-1,0,'B');
				if(in==80) vMoveNum(1,0,'B');
				if(in==75) vMoveNum(0,-1,'B');
				if(in==77) vMoveNum(0,1,'B');
			}
		}
		else if(in=='n')
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vDiv(-1,0,'B');
				if(in==80) vDiv(1,0,'B');
				if(in==75) vDiv(0,-1,'B');
				if(in==77) vDiv(0,1,'B');
			}
		}
		vPlus();
	}
}

void vInit()
{
	int i,j,x,y;
	string sSeed; 
	unsigned int sd=20190622;
	cout&lt;&lt;&quot;seed:&quot;&lt;&lt;endl;
	cin&gt;&gt;sSeed;
	system(&quot;cls&quot;);
	for(i=0;i&lt;sSeed.size();i++) sd=sd*233+sSeed[i];
	srand(sd);
	cMap[0][0]='A';
	hp[0][0]=pmain;
	vChange(0,0);
	cMap[msize-1][msize-1]='B';
	hp[msize-1][msize-1]=pmain;
	vChange(msize-1,msize-1);
	for(i=1;i&lt;=mount;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]='X';
			gotoxy(x,y*3);
			color(15,0);
			cout&lt;&lt;&quot; X&quot;;
		}
	}
	for(i=1;i&lt;=grey;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]='C';
			hp[x][y]=40+rand()%10;
			vChange(x,y);
		}
	}
	sx=sy=0;
	gotoxy(0,2);
	color(15,0);
	cout&lt;&lt;&quot;&lt;&quot;;
}

void vMove(int dx,int dy)
{
	color(15,0);
	dx+=sx;dy+=sy;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize)) return;
	gotoxy(sx,sy*3+2);
	cout&lt;&lt;&quot; &quot;;
	sx=dx;sy=dy;
	gotoxy(sx,sy*3+2);
	cout&lt;&lt;&quot;&lt;&quot;;
	gotoxy(msize+1,0);
	cout&lt;&lt;&quot;cMap=&quot;&lt;&lt;cMap[dx][dy]&lt;&lt;&quot;,hp=&quot;&lt;&lt;hp[dx][dy]&lt;&lt;&quot;            &quot;;
}

void vMoveNum(int x,int y,int dx,int dy,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	if(cMap[x][y]!=a&amp;&amp;cMap[x][y]!=A) return;
	dx+=x;dy+=y;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;cMap[dx][dy]!='X')) return;
	char &amp;cd=cMap[dx][dy];
	int &amp;hd=hp[dx][dy],&amp;hs=hp[x][y];
	if(cd!=a&amp;&amp;cd!=A&amp;&amp;hd&gt;=hs-1) return;
	if(cd==0)
	{
		cd=a;
		hd=hs-1;
	}
	else if(cd==A||cd==a)
	{
		hd+=hs-1;
	}
	else if(cd==B||cd==b)
	{
		if(B=='B') cd--;
		else cd++;
		hd=hs-1-hd;
	}
	else//'C'
	{
		cd=A;
		hd=hs-1-hd;
	}
	hs=1;
	vChange(dx,dy);
	vChange(x,y);
}

void vMoveNum(int dx,int dy,char A)
{
	vMoveNum(sx,sy,dx,dy,A);
	vMove(dx,dy);
}

void vDiv(int dx,int dy,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	if(cMap[sx][sy]!=a&amp;&amp;cMap[sx][sy]!=A) return;
	dx+=sx;dy+=sy;
	if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;cMap[dx][dy]!='X')) return;
	char &amp;cd=cMap[dx][dy];
	int &amp;hd=hp[dx][dy],&amp;hs=hp[sx][sy],tmp=hs/2;
	if(tmp==0) return;
	if(cd!=a&amp;&amp;cd!=A&amp;&amp;hd&gt;=tmp-1) return;
	if(cd==0)
	{
		cd=a;
		hd=tmp;
	}
	else if(cd==A||cd==a)
	{
		hd+=tmp;
	}
	else if(cd==B||cd==b)
	{
		if(B=='B') cd--;
		else cd++;
		hd=tmp-hd;
	}
	else//'C'
	{
		cd=A;
		hd=tmp-hd;
	}
	hs-=tmp;
	vChange(dx,dy);
	vChange(sx,sy);
	vMove(dx-sx,dy-sy);
}

void vDecide(char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	int i,j,k,x,y,dx,dy;
	dRet tmp,res;
	bool bd=false,bm=false;
	for(i=(A=='A')?0:(msize-1);(A=='A')?(i&lt;=msize-1):(i&gt;=0);(A=='A')?(i++):(i--))
	{
		for(j=(A=='A')?0:(msize-1);(A=='A')?(j&lt;=msize-1):(j&gt;=0);(A=='A')?(j++):(j--))
		{
			if(!bd&amp;&amp;(cMap[i][j]==B||cMap[i][j]=='C'))
			{
				tmp=bfs(i,j,A);
				if(tmp.dx+tmp.dy==0) continue;
				bd=true;
				res=tmp;
			}
			if(!bd&amp;&amp;!bm&amp;&amp;(cMap[i][j]==A||cMap[i][j]==a)&amp;&amp;hp[i][j]&gt;1)
			{
				for(k=0;k&lt;4;k++)
				{
					dx=dir[k][0]+i;
					dy=dir[k][1]+j;
					if(!(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize)) continue;
					if((cMap[dx][dy]==0||cMap[dx][dy]==b)&amp;&amp;hp[dx][dy]&lt;hp[i][j]-1)
					{
						bm=true;
						res.dx=dir[k][0];
						res.dy=dir[k][1];
						res.x=i;
						res.y=j;
						break;
					}
				}
			}
			if(bd) break;
		}
		if(bd) break;
	}
	if(!bd&amp;&amp;!bm) return;
	vMoveNum(res.x,res.y,res.dx,res.dy,A);
}

dRet bfs(int x,int y,char A)
{
	char a,B,b;
	a=A-'A'+'a';
	B=(A=='A')?'B':'A';
	b=B-'A'+'a';
	int i,dx,dy;
	dRet ret;
	node now,nxt;
	queue&lt;node&gt;q;
	now.step=hp[x][y]+2;
	now.x=x;
	now.y=y;
	q.push(now);
	memset(bVis,false,sizeof bVis);
	bVis[x][y]=true;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(i=0;i&lt;4;i++)
		{
			dx=dir[i][0]+now.x;
			dy=dir[i][1]+now.y;
			if(dx&gt;=0&amp;&amp;dx&lt;msize&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;msize&amp;&amp;!bVis[dx][dy]&amp;&amp;cMap[dx][dy]!='X')
			{
				bVis[dx][dy]=true;
				if(cMap[dx][dy]==0) nxt.step=now.step+1;
				if(cMap[dx][dy]==b||cMap[dx][dy]==B||cMap[dx][dy]=='C') nxt.step=now.step+hp[dx][dy]+2;
				else
				{
					nxt.step=now.step-hp[dx][dy]+1;
					if(nxt.step&lt;-5&amp;&amp;(cMap[dx][dy]==A||cMap[dx][dy]==a))
					{
						ret.dx=-dir[i][0];
						ret.dy=-dir[i][1];
						ret.x=dx;
						ret.y=dy;
						return ret;
					}
				}
				nxt.x=dx;
				nxt.y=dy;
				q.push(nxt);
			}
		}
	}
	ret.dx=ret.dy=0;
	return ret;
}

void vPlus()
{
	int i,j,aa=0,ba=0,al=0,bl=0;
	if(nCount%lcnt==0)
	{
		for(i=0;i&lt;msize;i++)
		{
			for(j=0;j&lt;msize;j++)
			{
				if(cMap[i][j]=='a'||cMap[i][j]=='b')
				{
					hp[i][j]++;
					vChange(i,j);
				}
			}
		}
	}
	for(i=0;i&lt;msize;i++)
	{
		for(j=0;j&lt;msize;j++)
		{
			if(cMap[i][j]=='A'||cMap[i][j]=='B')
			{
				hp[i][j]+=pmain;
				vChange(i,j);
			}
			if(cMap[i][j]=='A'||cMap[i][j]=='a') al++,aa+=hp[i][j];
			if(cMap[i][j]=='B'||cMap[i][j]=='b') bl++,ba+=hp[i][j];
		}
	}
	color(15,0);
	gotoxy(msize+2,0);
	cout&lt;&lt;&quot;red army:&quot;&lt;&lt;aa&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;red land:&quot;&lt;&lt;al&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;blue army:&quot;&lt;&lt;ba&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	cout&lt;&lt;&quot;blue land:&quot;&lt;&lt;bl&lt;&lt;&quot;   &quot;&lt;&lt;endl;
	vEnd();
}

void vEnd()
{

	if(cMap[0][0]=='B')
	{
		cout&lt;&lt;&quot;blue win&quot;&lt;&lt;endl;
		while(1);
	}
	if(cMap[msize-1][msize-1]=='A')
	{
		cout&lt;&lt;&quot;red win&quot;&lt;&lt;endl;
		while(1);
	}
}

void vChange(int x,int y)
{
	int c;
	char cm=cMap[x][y];
	if(cm=='A') c=cA;
	if(cm=='a') c=ca;
	if(cm=='B') c=cB;
	if(cm=='b') c=cb;
	if(cm=='C') c=cC;
	gotoxy(x,y*3);
	color(15,c);
	int val=hp[x][y];
	if(val&lt;10) cout&lt;&lt;&quot; &quot;&lt;&lt;val;
	else if(val&lt;100) cout&lt;&lt;val;
	else if(val&lt;1000) cout&lt;&lt;val/100&lt;&lt;&quot;e&quot;;
	else if(val&lt;10000) cout&lt;&lt;val/1000&lt;&lt;&quot;k&quot;;
	else if(val&lt;100000) cout&lt;&lt;val/10000&lt;&lt;&quot;w&quot;;
	else cout&lt;&lt;&quot;ju&quot;;
}

void gotoxy(int x,int y)
{
	COORD c;
	c.X=y;
	c.Y=x;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),c);
}

void color(int t,int b)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),t+b*16);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[匈牙利算法总结]]></title>
        <id>https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/</id>
        <link href="https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/">
        </link>
        <updated>2022-01-14T12:28:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="part-0前言">Part 0：前言</h3>
<p>学了这个算法好多次了，是时候总结一下啦😆</p>
<h3 id="part-1几个概念">Part 1：几个概念</h3>
<ul>
<li><strong>二分图</strong>：一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。</li>
<li><strong>最大匹配数</strong>：二分图中没有公共端点的边的数量的最大值。</li>
<li><strong>最小点覆盖</strong>：我们想找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。</li>
<li><strong>匈牙利算法</strong>：一种用来解决<strong>最大匹配数</strong>和<strong>最小点覆盖</strong>问题的算法。</li>
</ul>
<h3 id="part-2二分图最大匹配问题">Part 2：二分图最大匹配问题</h3>
<figure data-type="image" tabindex="1"><img src="https://yydcc-blog.github.io//post-images/1642164375763.png" alt="" loading="lazy"></figure>
<p>这里举例一个二分图，来模拟匹配的过程。</p>
<p>很明显，这里的最大匹配是3。</p>
<h4 id="匈牙利算法的过程模拟">匈牙利算法的过程模拟：</h4>
<p>我们先暂时把1和2连在一起。</p>
<p>现在3也可以和2连，这时我们返过去看和2相连的1。</p>
<p>由于1只能和2连，所以3连不上2。</p>
<p>那么3还有选择么？有，可以和6连。</p>
<p>这时6只能和3连。</p>
<p>再看4，和5连即可。</p>
<p>这就是匈牙利算法的流程，至于具体实现，我们来看看代码：</p>
<pre><code class="language-cpp">int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i){
    for (int j = 1; j &lt;= N; ++j)
        if (Map[i][j] &amp;&amp; !vis[j]){ //有边且未访问
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])){ //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian(){
    int cnt = 0;
    for (int i = 1; i &lt;= M; ++i){
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
</code></pre>
<p>通过算法我们可以发现，单次找边的过程是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的，一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点，所以总体复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p>
<p>（因为复杂度大，所以题目的限制一般较大，可以直接用邻接矩阵存储）</p>
<h3 id="part-3二分图最小点覆盖问题">Part 3：二分图最小点覆盖问题</h3>
<p>这里引入<strong>König定理</strong>：</p>
<blockquote>
<p>一个二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
</blockquote>
<p>直接解决。</p>
<h3 id="part-4例题">Part 4：例题</h3>
<p>这里只举例一题：<strong>洛谷 P1129 [ZJOI2007] 矩阵游戏</strong></p>
<blockquote>
<p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：<br>
行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。<br>
列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。<br>
游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。<br>
对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p>
</blockquote>
<p>通过枚举样例，我们发现：任意2个黑色方块，如果它们初始状态时不在同一行（列），那么无论如何交换，它们都不会在同一行（列）。</p>
<p>所以我们只需判断每一行是否都可以合法匹配即可。</p>
<p>AC代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int mp[205][205],p[205],vis[205],n,T;
bool match(int i){
	for(int j=1;j&lt;=n;j++) {
		if(mp[i][j]&amp;&amp;!vis[j]){
			vis[j]=1;
			if(!p[j]||match(p[j])) {
				p[j]=i;
				return 1;
			}
		}
	}
	return 0;
}
int Hungarian(){
	int cnt=0;
	for (int i=1;i&lt;=n;i++) {
		memset(vis,0,sizeof(vis));
		if (match(i))cnt++;
	}
	return cnt;
}
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--){
		scanf(&quot;%d&quot;,&amp;n);
		memset(p,0,sizeof(p));
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf(&quot;%d&quot;,&amp;mp[i][j]);
		if(Hungarian()==n)puts(&quot;Yes&quot;);
		else puts(&quot;No&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="part-5总结">Part 5：总结</h3>
<p>匈牙利算法是一个比较基础的图论算法，思路较简单，一定要记牢啊😙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你好！CSP-J-2021]]></title>
        <id>https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/</id>
        <link href="https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/">
        </link>
        <updated>2022-01-11T12:11:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="day-27">Day -27：</h3>
<p>今年复赛终于进了，压线两分。</p>
<p>我觉得只要进了就好，没别的要求。</p>
<p>S组差亿点点QWQ。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-26">Day -26：</h3>
<p>开始准备复赛。</p>
<p>搞了一些网课什么的，模拟赛打一打。<s>鱼摸一摸</s></p>
<hr>
<h3 id="day-1-afternoon">Day -1 afternoon：</h3>
<p>逃了学校的两堂课，直接出发去酒店。</p>
<p>晚上大吃一顿然后看看防爆零事项什么的。</p>
<p>总体来说准备很充分，剩下的看老天爷了。</p>
<hr>
<h3 id="day-1-night">Day -1 night：</h3>
<p>杭州真的好热，晚上有睡没睡的。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-1-morning">Day 1 morning：</h3>
<p>在酒店大堂吃了顿早餐就出发了。</p>
<p>在门口遇见一堆大佬（wjz ghj yjy sk）</p>
<p>进场时绕了好久，在考场外等了好久。</p>
<hr>
<h3 id="day-1-csp-j-2021">Day 1 CSP-J-2021：</h3>
<p>今年出题人是真的良心。</p>
<p>四道题三道模拟一道暴力。（bushi）</p>
<p>T1就是一道数学题，模几个样例就想到做法了。</p>
<p>然后我先做了T3，根据大样例找了好久的错。</p>
<p>这时比赛已经过半了（T3 98行代码自愧不如）<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<p>T2读了好久的题，草稿纸都快写满了。</p>
<p>突然发现好水然后测了大样例就去做T4了。</p>
<p>T4链表写炸，最后用了个暴力。</p>
<p>一开始直接用肉眼看大样例答案，后来想到可以用cmd的fc，但又不会改目录，就写了一个check来判断。</p>
<hr>
<h3 id="day-1-noon">Day 1 noon：</h3>
<p>比完后在附近吃了饭，然后就退房返城。</p>
<hr>
<h3 id="day-n">Day n:</h3>
<p>洛谷自测300+</p>
<p>J组1=，满足了</p>
<h2 id="再见csp-j-2021">再见！CSP-J-2021</h2>
<h6 id="补充个人认为难度t4t2t3t1">补充：个人认为难度T4&gt;T2&gt;T3&gt;T1</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[yorg.io 进阶攻略]]></title>
        <id>https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/</id>
        <link href="https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/">
        </link>
        <updated>2022-01-09T13:04:17.000Z</updated>
        <content type="html"><![CDATA[<p>这是我精心编写的攻略，喜欢大家喜欢😄</p>
<h3 id="前言">前言</h3>
<p>这是一个休闲类塔防网页游戏，也有单机版。</p>
<p>游戏地址：<a href="https://yorg.io/">link</a></p>
<h3 id="第一步度过前期第1~50天">第一步：度过前期（第1~50天）</h3>
<ul>
<li>基地建在附近有最多水晶的地方，水晶之间距离越近越好。</li>
<li>前十几关都不需要建攻击塔，所有经济用于升级基地、水晶以及建墙，把所有水晶矿机升级到最高级。</li>
<li>前期不用建攻击塔怎么解决掉小兵和boss呢？靠墙拖着，拖到白天，所有小兵和boss都会在3/4的白天前被烧死，基地本身有的攻击力也会发挥作用。建墙有一定的技巧，一是在墙快要被摧毁的时候升级，它就回到满血状态，这样可以把时间拖到最长，操作的注意点是受到攻击时经常性按下暂停，升级墙；二是只需要特别加强4个方向的墙：东南、东北、西南、西北，大部分小兵主要是攻击这4个方向，三是保险一点围2层的墙，在4个方向上可以加到3-4层；</li>
<li>基地升到第6级时，开始建闪电塔，闪电塔是最有效的攻击武器；不要建其他攻击塔；</li>
<li>前期把所有技能点都点到提升矿机生产效率上，然后是工厂生产，最后是闪电攻击；</li>
</ul>
<h4 id="tips">tips:</h4>
<ul>
<li>boss一般是在防御最弱的方向发起攻击的；</li>
<li>如果你的建筑相隔较远，比如矿机、工厂和攻击塔之间，最好将连接的传输器升到最高级，这样可以大大加快运输的速度，快速补充弹药；</li>
<li>如果某一关搞砸了，可以读取存档，不过会损失一些资源；如果你在白天保存游戏，然后回到主界面，再进入，小兵就会消失（算是作弊把..）</li>
</ul>
<h4 id="结束前期这时level10-现有水晶在1千万以上">结束前期，这时Level10+。现有水晶在1千万以上。</h4>
<h3 id="第二步初步转型50天后">第二步：初步转型（50天后）</h3>
<ul>
<li>拆除你的所有设施。</li>
<li>重新安排你的水晶矿机，围绕着主基地排列。</li>
<li>重新安排其他矿机，让他们围绕着水晶矿机排列，我们把这个区域叫做一个矿区。</li>
<li>用运输线连接矿机，将各种工厂安置在运输线上。（如果你已经解锁了空间翘曲技术，请跳过这步）</li>
<li>在每个矿区周围安置弓箭塔8个，闪电塔4个。</li>
</ul>
<h3 id="第三步围墙转型">第三步：围墙转型</h3>
<ul>
<li>如果水晶多，定位到地图的边缘，按住字母E的同时按住ASDW控制方向，绘制出连续的城墙。</li>
<li>如果水晶少，在每个矿区周围搭建围墙。</li>
<li>制造僵尸通道（在围墙上开洞通往主基地）</li>
<li>在这个通道周围布满武器塔。</li>
</ul>
<h3 id="第四步还没有第四步">第四步：还没有第四步😙</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-J2021 题解]]></title>
        <id>https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/</id>
        <link href="https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/">
        </link>
        <updated>2022-01-09T03:08:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分糖果">分糖果</h2>
<h3 id="题意">题意</h3>
<p>选择<code>L~R</code>中的某个数 ， 使得<code>x mod k</code>的结果最大。</p>
<h3 id="思路">思路</h3>
<p>分两种情况考虑：</p>
<p>若 L 和 R 对 K 取模后在同一区间，则必然在 x=R 位置取到最大值；<br>
否则 L~R 必然跨越多个区间，则取模后的结果必然有 k-1。<br>
而对于是否在同一区间，在除以 k 后，商是否一致判断即可。</p>
<h3 id="参考代码">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int main() {
  ll n, l, r;
  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
  if (l / n != r / n) cout &lt;&lt; n - 1 &lt;&lt; endl;
  else cout &lt;&lt; r % n &lt;&lt; endl;
  return 0;
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<h3 id="题意-2">题意</h3>
<p>给定长度为 n 的整数序列 ，有 Q 种操作：</p>
<p>1：x v 修改序列 a 中的第 x 个元素 <code>a[x]</code> 为 v ，该操作次数不超过5000次；<br>
2：x 将数组进行稳定排序，求原先第 x 个元素排序后的位置。</p>
<h3 id="思路-2">思路</h3>
<p>不如维护将原先所有的 a 排序后的升序数组。对于所有操作，我们需要维护原位置到有序数组中的映射。</p>
<p>对于 1 操作，找到 <code>a[x]</code> 对应位置，显然修改值将使其往前或往后。联系到题目中提示的插入排序，可以不断向前/向后比较。注意同时维护映射关系。<br>
对于 2 操作，直接输出映射即可。<br>
注：如果该题中的数组长度更长、操作次数更多，我们可使用平衡树来解决该题。</p>
<h3 id="参考代码-2">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; pii;
const int N = 8e3+5;
int a[N];
pii p[N];

int main() {
  ios::sync_with_stdio(false);
  int n, q; cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i];
    p[i] = {a[i], i};
  }
  sort(p + 1, p + 1 + n);
  for (int i = 1; i &lt;= n; i++) a[p[i].second] = i;
  for (int i = 0, op, x, v; i &lt; q; i++) {
    cin &gt;&gt; op; 
    // 5000 * 8000 = 4e7
    if (op == 1) {
      cin &gt;&gt; x &gt;&gt; v;
      int pos = a[x];
      p[pos].first = v;
      while (pos &gt; 1 &amp;&amp; p[pos] &lt; p[pos - 1]) {
        swap(a[p[pos].second], a[p[pos - 1].second]);
        swap(p[pos], p[pos - 1]);
        pos--;
      } 
      while (pos &lt; n &amp;&amp; p[pos] &gt; p[pos + 1]) {
        swap(a[p[pos].second], a[p[pos + 1].second]);
        swap(p[pos], p[pos + 1]);
        pos++;
      }
    } else {
      cin &gt;&gt; x;
      cout &lt;&lt; a[x] &lt;&lt; endl;
    }
  }
  return 0;
}
</code></pre>
<h2 id="网络连接">网络连接</h2>
<h3 id="题意-3">题意</h3>
<p>解析带端口的IP地址串，按服务器和客户端角色判断连接情况。</p>
<h3 id="思路-3">思路</h3>
<p>若将带端口的IP地址串记为 a.b.c.d:e，则需要检查的项目有：</p>
<ul>
<li>有三个点号和一个冒号分隔字符串，且冒号出现在最后；</li>
<li>a,b,c,d,e均不为空，且不含有前导零；</li>
</ul>
<p>可将对字符串的解析抽象为函数，简化代码逻辑。</p>
<h3 id="参考代码-3">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string, int&gt; dict;
const int IP = 256;
const int PORT = 65536;

bool check(string s, int limit) {
  // &quot;.0.0.1:80&quot; -&gt; &quot;&quot;
  if (s.empty()) return false;
  // &quot;0127.0.0.1:80&quot; -&gt; &quot;0127&quot;
  if (s[0] == '0' &amp;&amp; s.size() &gt; 1) return false;
  int val = 0;
  for (int i = 0; i &lt; s.size(); i++) {
    val = val * 10 + s[i] - '0'; 
    if (val &gt;= limit) return false;
  }
  return true;
}

bool parse(string ip) {
  string s = &quot;&quot;;
  int dot_cnt = 0, port_cnt = 0;
  for (int i = 0; i &lt; ip.size(); i++) {
    if (ip[i] == '.') dot_cnt += 1;
    if (ip[i] == ':') {
      if (dot_cnt != 3) return false;
      port_cnt += 1;
    }
    if (!isdigit(ip[i])) {
      if (!check(s, IP)) return false;
      s = &quot;&quot;;
    } else s += ip[i];
  }
  return check(s, PORT) &amp;&amp; dot_cnt == 3 &amp;&amp; port_cnt == 1;
}

void process_server(string ip, int id) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  dict[ip] = id;
  cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
}

void process_client(string ip) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (!dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  cout &lt;&lt; dict[ip] &lt;&lt; endl;
}

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    string name, ip;
    cin &gt;&gt; name &gt;&gt; ip;
    if (name[0] == 'S') process_server(ip, i);
    else process_client(ip);
  }
  return 0;
}
</code></pre>
<h2 id="小熊的果篮">小熊的果篮</h2>
<h3 id="题意-4">题意</h3>
<p>有两类共 n 个水果拍成一排，称连续的排在一起的同一种水果称为“块”。</p>
<p>每次将每一个“块”中最左边的水果同时挑出。重复该操作直至水果用完。</p>
<p>每次水果被挑出后“块”会发生动态变化。</p>
<h3 id="思路-4">思路</h3>
<p>尝试建模每个块，使用块头来表示每个块的开始位置，即第一个元素或与上一个元素类型不同的位置。</p>
<p>每个元素之间使用双向链表相连接。</p>
<p>对于每次输出选出的元素，我们只需要依次输出块头元素，并从双向链表中删除该元素。</p>
<p>当块头元素输出后，需要更新块头列表。<br>
考虑在原块头位置的下一个元素，只有当：</p>
<ul>
<li>该下一个元素与原块头位置的上一个元素类型不同；</li>
<li>该下一个元素不是原块头。</li>
</ul>
<p>则能够成为新的块头位置。</p>
<h3 id="参考代码-4">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5+5;
struct Node {
  int pre, nxt, v;
}a[N];
vector&lt;int&gt; head, nxt_head;

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  a[0].v = a[n + 1].v = -1;
  a[0].nxt = 1;
  a[n + 1].pre = n;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i].v;
    a[i].pre = i - 1;
    a[i].nxt = i + 1;
    if (a[i].v != a[i - 1].v) head.push_back(i);
  }
  while(head.size()) {
    nxt_head.clear();
    for (int id : head) {
      cout &lt;&lt; id &lt;&lt; &quot; &quot;;
      Node&amp; node = a[id];
      a[node.pre].nxt = node.nxt;
      a[node.nxt].pre = node.pre;
      if (node.v == a[node.nxt].v &amp;&amp; node.v != a[node.pre].v)
        nxt_head.push_back(node.nxt);
    }
    cout &lt;&lt; endl;
    swap(head, nxt_head);
  }
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树形DP总结]]></title>
        <id>https://yydcc-blog.github.io/post/shu-xing-dp-zong-jie/</id>
        <link href="https://yydcc-blog.github.io/post/shu-xing-dp-zong-jie/">
        </link>
        <updated>2022-01-09T03:04:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-0-前言">Part 0 前言</h1>
<p>刚学完了树形DP，是时候来总结一下了！😀</p>
<h1 id="part-1-基础部分">Part 1 基础部分</h1>
<p>树形DP就是在树上的DP。</p>
<p>这里先放一下遍历树的模板：</p>
<pre><code class="language-cpp">void dfs(int u,int fa){
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
	}
}
</code></pre>
<p>DP的操作就放在dfs操作的后面，再加上初值和特判，就变成了这样：</p>
<pre><code class="language-cpp">void dfs(int u,int fa){
	|初值定义| 
	if(|特判条件|)|特判操作| 
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
		|DP操作|
	}
}
</code></pre>
<h1 id="part-2-练习部分">Part 2 练习部分</h1>
<h3 id="p1352-没有上司的舞会">P1352 没有上司的舞会</h3>
<p><strong>难度</strong>：★★☆☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，每次只能取父节点的权或子节点的权，求最大的点权和为多少。</p>
<p><strong>分析</strong>：因为能不能区由子节点决定，那么可以设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i  ,0/1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 取（1）和不取（0）的最大权值和。转移方程就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i,1} = f_{j,0} + a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i,0} = max(f_{j,0} , f_{j,1})+ a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值）。答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">max(f_{root,0},f_{root,1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define maxn 6005
using namespace std;
int n,head[maxn],nex[maxn],to[maxn],f[maxn][2],num[maxn],edgenum;
bool root[maxn];
void addedge(int u,int v){ 
	nex[++edgenum]=head[u];
	to[edgenum]=v;
	head[u]=edgenum;
	root[v]=1;
}
void dp(int u){
	f[u][0]=0;//定义初值 
	f[u][1]=num[u];
	for(int i=head[u];i;i=nex[i]){
		int v=to[i];
		dp(v);
		f[u][0]+=max(f[v][0],f[v][1]);//DP操作 
		f[u][1]+=f[v][0];
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;num[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		addedge(v,u);
	}
	for(int i=1;i&lt;=n;i++)
		if(!root[i]){//是否为根节点 
			dp(i);
			printf(&quot;%d\n&quot;,max(f[i][0],f[i][1]));//输出答案 
			break;
		}
	return 0;
}
</code></pre>
<h3 id="p1122-最大子树和">P1122 最大子树和</h3>
<p><strong>难度</strong>：★☆☆☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，让你求最大的子树权值和。</p>
<p><strong>分析</strong>：因为要求最大子树和，所以设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为以节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 为根的最大子树和。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>f</mi><mi>v</mi></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u = max(0,f_v)+a_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">a_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的权值）。答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最大值。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct edge {
	int next,to;
} e[100000];
int n,a[100000],head[100000],cnt,f[100000],ans;
void add(int x,int y) {
	e[++cnt].next=head[x];
	e[cnt].to=y;
	head[x]=cnt;
}
void dfs(int u,int fa) {
	f[u]=a[u];
	for(int i=head[u]; i; i=e[i].next) {
		int v=e[i].to;
		if(v!=fa) { 
			dfs(v,u);
			f[u]+=max(0,f[v]);//相加 
		}
	}
	ans=max(ans,f[u]);//记录最大值 
}
int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;n; i++) {
		int x,y; 
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="p2015-二叉苹果树">P2015 二叉苹果树</h3>
<p><strong>难度</strong>：★★★☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的二叉树，求一颗有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 条边的子树的最大点权和。</p>
<p><strong>分析</strong>：通过样例可以看出这是一道树上的 <a href="https://baike.baidu.com/item/01%E8%83%8C%E5%8C%85/4301245?fr=aladdin">01背包</a> 题目，通过类比思想把状态转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{x,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示当前节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的子树上保留 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 条边的最大点权和。转移就变成了这样：</p>
<pre><code class="language-cpp">for(int j=q;j&gt;=1;j--)
	for(int k=j-1;k&gt;=0;k--)
		f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
</code></pre>
<p>搜索，每一个点找出以它为根节点的1~q的最大利益，除叶节点外。因为连接父节点和子节点还有一条边，所以父节点自己留的可用边-1。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,q;
int f[1005][1005],edgenum,len[1009],head[1009],to[1005],nxt[1005];
void addedge(int u,int v,int l){
	nxt[++edgenum]=head[u];
	to[edgenum]=v;
	len[edgenum]=l;
	head[u]=edgenum;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		used[v]=1;
		dfs(v,u);
		for(int j=q;j&gt;=1;j--)//01背包要倒着做 
			for(int k=j-1;k&gt;=0;k--)
				f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
	}
}

int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
	for(int i=1;i&lt;n;i++){
		int x,y,z;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);//双向建边 
		addedge(y,x,z);
	}
	dfs(1,0);
	printf(&quot;%d&quot;,f[1][q]);
	return 0;
}
</code></pre>
<h3 id="p2014-ctsc1997选课">P2014 [CTSC1997]选课</h3>
<p><strong>难度</strong>：★★★☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，求一棵有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 个点的子树的最大权值和。</p>
<p><strong>分析</strong>：跟上面一题差不多，只是变成了单向边。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=305,M=2001;
int f[N][N],edgenum,n,m;
int head[M],nxt[M],to[M];
void addedge(int u,int v){
    nxt[++edgenum]=head[u];
    to[edgenum]=v;
    head[u]=edgenum;
}
void dp(int x){
    for(int e=head[x];e;e=nxt[e]){
        int v=to[e];
        dp(v);
        for(int i=m+1;i&gt;1;i--)
            for(int j=i-1;j&gt;=1;j--)
                f[x][i]=max(f[x][i],f[x][i-j]+f[v][j]);
    }
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        f[i][1]=b;
        addedge(a,i);
    }
    dp(0);
    printf(&quot;%d\n&quot;,f[0][m+1]);
    return 0;
}
</code></pre>
<h3 id="p1273-有线电视网">P1273 有线电视网</h3>
<p><strong>难度</strong>：★★★★☆</p>
<p><strong>题目大意</strong>：选出一个节点数量最多的叶子节点的集合，使这些点到根节点的路径上的权值和减去集合中所有的点的权值大于等于零。</p>
<p><strong>分析</strong>：设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树中，选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个叶子节点，点权-边权的最大值。<code>dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);</code>，最后找第一个大于等于零的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 即为答案。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,head[3010],edgenum,val[3010],dp[3010][3010];
struct node {
	int to,next,w;
} edge[10000];
void adde(int u,int v,int w) {
	edge[++edgenum].to=v;
	edge[edgenum].next=head[u];
	edge[edgenum].w=w;
	head[u]=edgenum;
}
int dfs(int u) {
	if(u&gt;n-m) {
		dp[u][1]=val[u];
		return 1;
	}
	int sum=0,t;
	for(int e=head[u]; e; e=edge[e].next) {
		int v=edge[e].to;
		t=dfs(v);
		sum+=t;
		for(int j=sum; j&gt;0; j--)
			for(int i=1; i&lt;=t; i++)
				if(j-i&gt;=0) dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);
	}
	return sum;
}
int main() {
	memset(dp,~0x3f,sizeof(dp));
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int u=1; u&lt;=n-m; u++) {
		int size,v,w;
		scanf(&quot;%d&quot;,&amp;size);
		for(int j=1; j&lt;=size; j++) {
			scanf(&quot;%d%d&quot;,&amp;v,&amp;w);
			adde(u,v,w);
		}
	}
	for(int i=n-m+1; i&lt;=n; i++)
		scanf(&quot;%d&quot;,&amp;val[i]);
	for (int i=1; i&lt;=n; i++)
		dp[i][0]=0;
	dfs(1);
	for (int i=m; i&gt;=1; i--)
		if (dp[1][i]&gt;=0) {
			printf(&quot;%d&quot;,i);
			break;
		}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的几种存储方式]]></title>
        <id>https://yydcc-blog.github.io/post/tu-de-ji-chong-cun-chu-fang-shi/</id>
        <link href="https://yydcc-blog.github.io/post/tu-de-ji-chong-cun-chu-fang-shi/">
        </link>
        <updated>2022-01-09T02:24:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1邻接矩阵">1.邻接矩阵</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190128175511539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcyMTQyMw==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。</p>
<p>例如：用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不为0时表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>有一条边（也可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不为0时表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>有一条长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的边）</p>
<h3 id="实现">实现：</h3>
<pre><code>int x,y,z;//无向图带权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
mp[x][y]=z;
mp[y][x]=z;

int x,y,z;//有向图带权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
mp[x][y]=z;

int x,y;//无向图无权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y);
mp[x][y]=1;
mp[y][x]=1;

int x,y;//有向图无权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y);
mp[x][y]=1;
</code></pre>
<h3 id="邻接矩阵的好处">邻接矩阵的好处：</h3>
<p>1.直观、简单、好理解</p>
<p>2.方便检查任意一对定点间是否存在边</p>
<p>3.方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</p>
<p>4.方便计算任一顶点的度</p>
<p>对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。</p>
<p>对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。</p>
<h3 id="邻接矩阵的缺点">邻接矩阵的缺点：</h3>
<p>1.浪费空间（特别是在稀疏图中，有大量空余空间）</p>
<p>2.浪费时间（要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。）</p>
<p>所以我们需要下面这两个：</p>
<h1 id="2邻接表">2.邻接表</h1>
<p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法。</p>
<p>在邻接表中，对图中每个顶点建立一个单链表，第i个单链表中的节点表示依附于顶点i的边（对有向图是以顶点i为尾的边）。每个单链表上附设一个表头节点。</p>
<p>邻接表的特点如下：</p>
<p>1.邻接表表示不唯一。这是因为在每个顶点对应的单链表中，各边节点的链接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。</p>
<p>2.对于有n个顶点和e条边的无向图，其邻接表有n个顶点节点和2e个边节点。显然，在总的边数小于n(n-1)/2的情况下，邻接表比邻接矩阵要节省空间。</p>
<p>3.对于无向图，邻接表的顶点i对应的第i个链表的边节点数目正好是顶点i的度。</p>
<p>4.对于有向图，邻接表的顶点i对应的第i个链表的边节点数目仅仅是顶点i的出度。其入度为邻接表中所有adjvex域值为i的边节点数目。</p>
<h1 id="3链式前向星">3.链式前向星</h1>
<h3 id="1-结构">1. 结构</h3>
<p>这里用两个东西：</p>
<p>1 结构体数组edge存边，edge[i]表示第i条边,</p>
<p>2 head[i]存以i为起点的第一条边(在edge中的下标)</p>
<pre><code class="language-cpp">struct EDGE{
	int next;   //下一条边的存储下标(默认0) 
	int to;     //这条边的终点 
	int w;      //权值 
}edge[500010];
</code></pre>
<h3 id="2增边">2.增边</h3>
<p>若以点i为起点的边新增了一条，在edge中的下标为j.</p>
<p>那么edge[j].next=head[i];然后head[i]=j.</p>
<p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p>
<pre><code class="language-cpp">
void Add(int u, int v, int w) {  //起点u, 终点v, 权值w 
	//cnt为边的计数，从1开始计 
	edge[++cnt].next = head[u];
	edge[cnt].w = w;
	edge[cnt].to = v;
	head[u] = cnt;    //第一条边为当前边 
}
</code></pre>
<h3 id="3-遍历">3. 遍历</h3>
<p>遍历以st为起点的边</p>
<pre><code class="language-c++">for(int i=head[st]; i!=0; i=edge[i].next)
</code></pre>
<p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p>
<h1 id="然后就没有然后了">然后就没有然后了...</h1>
]]></content>
    </entry>
</feed>