<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yydcc-blog.github.io/</id>
    <title>永远的CC的博客</title>
    <updated>2022-01-14T13:24:56.975Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yydcc-blog.github.io/"/>
    <link rel="self" href="https://yydcc-blog.github.io/atom.xml"/>
    <subtitle>永远的CC，永远为你</subtitle>
    <logo>https://yydcc-blog.github.io/images/avatar.png</logo>
    <icon>https://yydcc-blog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 永远的CC的博客</rights>
    <entry>
        <title type="html"><![CDATA[匈牙利算法总结]]></title>
        <id>https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/</id>
        <link href="https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/">
        </link>
        <updated>2022-01-14T12:28:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="part-0前言">Part 0：前言</h3>
<p>学了这个算法好多次了，是时候总结一下啦😆</p>
<h3 id="part-1几个概念">Part 1：几个概念</h3>
<ul>
<li><strong>二分图</strong>：一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。</li>
<li><strong>最大匹配数</strong>：二分图中没有公共端点的边的数量的最大值。</li>
<li><strong>最小点覆盖</strong>：我们想找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。</li>
<li><strong>匈牙利算法</strong>：一种用来解决<strong>最大匹配数</strong>和<strong>最小点覆盖</strong>问题的算法。</li>
</ul>
<h3 id="part-2二分图最大匹配问题">Part 2：二分图最大匹配问题</h3>
<figure data-type="image" tabindex="1"><img src="https://yydcc-blog.github.io//post-images/1642164375763.png" alt="" loading="lazy"></figure>
<p>这里举例一个二分图，来模拟匹配的过程。</p>
<p>很明显，这里的最大匹配是3。</p>
<h4 id="匈牙利算法的过程模拟">匈牙利算法的过程模拟：</h4>
<p>我们先暂时把1和2连在一起。</p>
<p>现在3也可以和2连，这时我们返过去看和2相连的1。</p>
<p>由于1只能和2连，所以3连不上2。</p>
<p>那么3还有选择么？有，可以和6连。</p>
<p>这时6只能和3连。</p>
<p>再看4，和5连即可。</p>
<p>这就是匈牙利算法的流程，至于具体实现，我们来看看代码：</p>
<pre><code class="language-cpp">int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i){
    for (int j = 1; j &lt;= N; ++j)
        if (Map[i][j] &amp;&amp; !vis[j]){ //有边且未访问
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])){ //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian(){
    int cnt = 0;
    for (int i = 1; i &lt;= M; ++i){
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
</code></pre>
<p>通过算法我们可以发现，单次找边的过程是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的，一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点，所以总体复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p>
<p>（因为复杂度大，所以题目的限制一般较大，可以直接用邻接矩阵存储）</p>
<h3 id="part-3二分图最小点覆盖问题">Part 3：二分图最小点覆盖问题</h3>
<p>这里引入<strong>König定理</strong>：</p>
<blockquote>
<p>一个二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
</blockquote>
<p>直接解决。</p>
<h3 id="part-4例题">Part 4：例题</h3>
<p>这里只举例一题：<strong>洛谷 P1129 [ZJOI2007] 矩阵游戏</strong></p>
<blockquote>
<p>小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：<br>
行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。<br>
列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。<br>
游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。<br>
对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。</p>
</blockquote>
<p>通过枚举样例，我们发现：任意2个黑色方块，如果它们初始状态时不在同一行（列），那么无论如何交换，它们都不会在同一行（列）。</p>
<p>所以我们只需判断每一行是否都可以合法匹配即可。</p>
<p>AC代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int mp[205][205],p[205],vis[205],n,T;
bool match(int i){
	for(int j=1;j&lt;=n;j++) {
		if(mp[i][j]&amp;&amp;!vis[j]){
			vis[j]=1;
			if(!p[j]||match(p[j])) {
				p[j]=i;
				return 1;
			}
		}
	}
	return 0;
}
int Hungarian(){
	int cnt=0;
	for (int i=1;i&lt;=n;i++) {
		memset(vis,0,sizeof(vis));
		if (match(i))cnt++;
	}
	return cnt;
}
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--){
		scanf(&quot;%d&quot;,&amp;n);
		memset(p,0,sizeof(p));
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf(&quot;%d&quot;,&amp;mp[i][j]);
		if(Hungarian()==n)puts(&quot;Yes&quot;);
		else puts(&quot;No&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="part-5总结">Part 5：总结</h3>
<p>匈牙利算法是一个比较基础的图论算法，思路较简单，一定要记牢啊😙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你好！CSP-J-2021]]></title>
        <id>https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/</id>
        <link href="https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/">
        </link>
        <updated>2022-01-11T12:11:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="day-27">Day -27：</h3>
<p>今年复赛终于进了，压线两分。</p>
<p>我觉得只要进了就好，没别的要求。</p>
<p>S组差亿点点QWQ。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-26">Day -26：</h3>
<p>开始准备复赛。</p>
<p>搞了一些网课什么的，模拟赛打一打。<s>鱼摸一摸</s></p>
<hr>
<h3 id="day-1-afternoon">Day -1 afternoon：</h3>
<p>逃了学校的两堂课，直接出发去酒店。</p>
<p>晚上大吃一顿然后看看防爆零事项什么的。</p>
<p>总体来说准备很充分，剩下的看老天爷了。</p>
<hr>
<h3 id="day-1-night">Day -1 night：</h3>
<p>杭州真的好热，晚上有睡没睡的。<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<hr>
<h3 id="day-1-morning">Day 1 morning：</h3>
<p>在酒店大堂吃了顿早餐就出发了。</p>
<p>在门口遇见一堆大佬（wjz ghj yjy sk）</p>
<p>进场时绕了好久，在考场外等了好久。</p>
<hr>
<h3 id="day-1-csp-j-2021">Day 1 CSP-J-2021：</h3>
<p>今年出题人是真的良心。</p>
<p>四道题三道模拟一道暴力。（bushi）</p>
<p>T1就是一道数学题，模几个样例就想到做法了。</p>
<p>然后我先做了T3，根据大样例找了好久的错。</p>
<p>这时比赛已经过半了（T3 98行代码自愧不如）<br>
<img src="https://xn--9zr.tk/kk" alt="" loading="lazy"></p>
<p>T2读了好久的题，草稿纸都快写满了。</p>
<p>突然发现好水然后测了大样例就去做T4了。</p>
<p>T4链表写炸，最后用了个暴力。</p>
<p>一开始直接用肉眼看大样例答案，后来想到可以用cmd的fc，但又不会改目录，就写了一个check来判断。</p>
<hr>
<h3 id="day-1-noon">Day 1 noon：</h3>
<p>比完后在附近吃了饭，然后就退房返城。</p>
<hr>
<h3 id="day-n">Day n:</h3>
<p>洛谷自测300+</p>
<p>J组1=，满足了</p>
<h2 id="再见csp-j-2021">再见！CSP-J-2021</h2>
<h6 id="补充个人认为难度t4t2t3t1">补充：个人认为难度T4&gt;T2&gt;T3&gt;T1</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[yorg.io 进阶攻略]]></title>
        <id>https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/</id>
        <link href="https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/">
        </link>
        <updated>2022-01-09T13:04:17.000Z</updated>
        <content type="html"><![CDATA[<p>这是我精心编写的攻略，喜欢大家喜欢😄</p>
<h3 id="前言">前言</h3>
<p>这是一个休闲类塔防网页游戏，也有单机版。</p>
<p>游戏地址：<a href="https://yorg.io/">link</a></p>
<h3 id="第一步度过前期第1~50天">第一步：度过前期（第1~50天）</h3>
<ul>
<li>基地建在附近有最多水晶的地方，水晶之间距离越近越好。</li>
<li>前十几关都不需要建攻击塔，所有经济用于升级基地、水晶以及建墙，把所有水晶矿机升级到最高级。</li>
<li>前期不用建攻击塔怎么解决掉小兵和boss呢？靠墙拖着，拖到白天，所有小兵和boss都会在3/4的白天前被烧死，基地本身有的攻击力也会发挥作用。建墙有一定的技巧，一是在墙快要被摧毁的时候升级，它就回到满血状态，这样可以把时间拖到最长，操作的注意点是受到攻击时经常性按下暂停，升级墙；二是只需要特别加强4个方向的墙：东南、东北、西南、西北，大部分小兵主要是攻击这4个方向，三是保险一点围2层的墙，在4个方向上可以加到3-4层；</li>
<li>基地升到第6级时，开始建闪电塔，闪电塔是最有效的攻击武器；不要建其他攻击塔；</li>
<li>前期把所有技能点都点到提升矿机生产效率上，然后是工厂生产，最后是闪电攻击；</li>
</ul>
<h4 id="tips">tips:</h4>
<ul>
<li>boss一般是在防御最弱的方向发起攻击的；</li>
<li>如果你的建筑相隔较远，比如矿机、工厂和攻击塔之间，最好将连接的传输器升到最高级，这样可以大大加快运输的速度，快速补充弹药；</li>
<li>如果某一关搞砸了，可以读取存档，不过会损失一些资源；如果你在白天保存游戏，然后回到主界面，再进入，小兵就会消失（算是作弊把..）</li>
</ul>
<h4 id="结束前期这时level10-现有水晶在1千万以上">结束前期，这时Level10+。现有水晶在1千万以上。</h4>
<h3 id="第二步初步转型50天后">第二步：初步转型（50天后）</h3>
<ul>
<li>拆除你的所有设施。</li>
<li>重新安排你的水晶矿机，围绕着主基地排列。</li>
<li>重新安排其他矿机，让他们围绕着水晶矿机排列，我们把这个区域叫做一个矿区。</li>
<li>用运输线连接矿机，将各种工厂安置在运输线上。（如果你已经解锁了空间翘曲技术，请跳过这步）</li>
<li>在每个矿区周围安置弓箭塔8个，闪电塔4个。</li>
</ul>
<h3 id="第三步围墙转型">第三步：围墙转型</h3>
<ul>
<li>如果水晶多，定位到地图的边缘，按住字母E的同时按住ASDW控制方向，绘制出连续的城墙。</li>
<li>如果水晶少，在每个矿区周围搭建围墙。</li>
<li>制造僵尸通道（在围墙上开洞通往主基地）</li>
<li>在这个通道周围布满武器塔。</li>
</ul>
<h3 id="第四步还没有第四步">第四步：还没有第四步😙</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-J2021 题解]]></title>
        <id>https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/</id>
        <link href="https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/">
        </link>
        <updated>2022-01-09T03:08:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分糖果">分糖果</h2>
<h3 id="题意">题意</h3>
<p>选择<code>L~R</code>中的某个数 ， 使得<code>x mod k</code>的结果最大。</p>
<h3 id="思路">思路</h3>
<p>分两种情况考虑：</p>
<p>若 L 和 R 对 K 取模后在同一区间，则必然在 x=R 位置取到最大值；<br>
否则 L~R 必然跨越多个区间，则取模后的结果必然有 k-1。<br>
而对于是否在同一区间，在除以 k 后，商是否一致判断即可。</p>
<h3 id="参考代码">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int main() {
  ll n, l, r;
  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
  if (l / n != r / n) cout &lt;&lt; n - 1 &lt;&lt; endl;
  else cout &lt;&lt; r % n &lt;&lt; endl;
  return 0;
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<h3 id="题意-2">题意</h3>
<p>给定长度为 n 的整数序列 ，有 Q 种操作：</p>
<p>1：x v 修改序列 a 中的第 x 个元素 <code>a[x]</code> 为 v ，该操作次数不超过5000次；<br>
2：x 将数组进行稳定排序，求原先第 x 个元素排序后的位置。</p>
<h3 id="思路-2">思路</h3>
<p>不如维护将原先所有的 a 排序后的升序数组。对于所有操作，我们需要维护原位置到有序数组中的映射。</p>
<p>对于 1 操作，找到 <code>a[x]</code> 对应位置，显然修改值将使其往前或往后。联系到题目中提示的插入排序，可以不断向前/向后比较。注意同时维护映射关系。<br>
对于 2 操作，直接输出映射即可。<br>
注：如果该题中的数组长度更长、操作次数更多，我们可使用平衡树来解决该题。</p>
<h3 id="参考代码-2">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; pii;
const int N = 8e3+5;
int a[N];
pii p[N];

int main() {
  ios::sync_with_stdio(false);
  int n, q; cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i];
    p[i] = {a[i], i};
  }
  sort(p + 1, p + 1 + n);
  for (int i = 1; i &lt;= n; i++) a[p[i].second] = i;
  for (int i = 0, op, x, v; i &lt; q; i++) {
    cin &gt;&gt; op; 
    // 5000 * 8000 = 4e7
    if (op == 1) {
      cin &gt;&gt; x &gt;&gt; v;
      int pos = a[x];
      p[pos].first = v;
      while (pos &gt; 1 &amp;&amp; p[pos] &lt; p[pos - 1]) {
        swap(a[p[pos].second], a[p[pos - 1].second]);
        swap(p[pos], p[pos - 1]);
        pos--;
      } 
      while (pos &lt; n &amp;&amp; p[pos] &gt; p[pos + 1]) {
        swap(a[p[pos].second], a[p[pos + 1].second]);
        swap(p[pos], p[pos + 1]);
        pos++;
      }
    } else {
      cin &gt;&gt; x;
      cout &lt;&lt; a[x] &lt;&lt; endl;
    }
  }
  return 0;
}
</code></pre>
<h2 id="网络连接">网络连接</h2>
<h3 id="题意-3">题意</h3>
<p>解析带端口的IP地址串，按服务器和客户端角色判断连接情况。</p>
<h3 id="思路-3">思路</h3>
<p>若将带端口的IP地址串记为 a.b.c.d:e，则需要检查的项目有：</p>
<ul>
<li>有三个点号和一个冒号分隔字符串，且冒号出现在最后；</li>
<li>a,b,c,d,e均不为空，且不含有前导零；</li>
</ul>
<p>可将对字符串的解析抽象为函数，简化代码逻辑。</p>
<h3 id="参考代码-3">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string, int&gt; dict;
const int IP = 256;
const int PORT = 65536;

bool check(string s, int limit) {
  // &quot;.0.0.1:80&quot; -&gt; &quot;&quot;
  if (s.empty()) return false;
  // &quot;0127.0.0.1:80&quot; -&gt; &quot;0127&quot;
  if (s[0] == '0' &amp;&amp; s.size() &gt; 1) return false;
  int val = 0;
  for (int i = 0; i &lt; s.size(); i++) {
    val = val * 10 + s[i] - '0'; 
    if (val &gt;= limit) return false;
  }
  return true;
}

bool parse(string ip) {
  string s = &quot;&quot;;
  int dot_cnt = 0, port_cnt = 0;
  for (int i = 0; i &lt; ip.size(); i++) {
    if (ip[i] == '.') dot_cnt += 1;
    if (ip[i] == ':') {
      if (dot_cnt != 3) return false;
      port_cnt += 1;
    }
    if (!isdigit(ip[i])) {
      if (!check(s, IP)) return false;
      s = &quot;&quot;;
    } else s += ip[i];
  }
  return check(s, PORT) &amp;&amp; dot_cnt == 3 &amp;&amp; port_cnt == 1;
}

void process_server(string ip, int id) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  dict[ip] = id;
  cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;
}

void process_client(string ip) {
  bool valid = parse(ip);
  if (!valid) {cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; return;}
  if (!dict.count(ip)) {cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; return;}
  cout &lt;&lt; dict[ip] &lt;&lt; endl;
}

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    string name, ip;
    cin &gt;&gt; name &gt;&gt; ip;
    if (name[0] == 'S') process_server(ip, i);
    else process_client(ip);
  }
  return 0;
}
</code></pre>
<h2 id="小熊的果篮">小熊的果篮</h2>
<h3 id="题意-4">题意</h3>
<p>有两类共 n 个水果拍成一排，称连续的排在一起的同一种水果称为“块”。</p>
<p>每次将每一个“块”中最左边的水果同时挑出。重复该操作直至水果用完。</p>
<p>每次水果被挑出后“块”会发生动态变化。</p>
<h3 id="思路-4">思路</h3>
<p>尝试建模每个块，使用块头来表示每个块的开始位置，即第一个元素或与上一个元素类型不同的位置。</p>
<p>每个元素之间使用双向链表相连接。</p>
<p>对于每次输出选出的元素，我们只需要依次输出块头元素，并从双向链表中删除该元素。</p>
<p>当块头元素输出后，需要更新块头列表。<br>
考虑在原块头位置的下一个元素，只有当：</p>
<ul>
<li>该下一个元素与原块头位置的上一个元素类型不同；</li>
<li>该下一个元素不是原块头。</li>
</ul>
<p>则能够成为新的块头位置。</p>
<h3 id="参考代码-4">参考代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5+5;
struct Node {
  int pre, nxt, v;
}a[N];
vector&lt;int&gt; head, nxt_head;

int main() {
  ios::sync_with_stdio(false);
  int n; cin &gt;&gt; n;
  a[0].v = a[n + 1].v = -1;
  a[0].nxt = 1;
  a[n + 1].pre = n;
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i].v;
    a[i].pre = i - 1;
    a[i].nxt = i + 1;
    if (a[i].v != a[i - 1].v) head.push_back(i);
  }
  while(head.size()) {
    nxt_head.clear();
    for (int id : head) {
      cout &lt;&lt; id &lt;&lt; &quot; &quot;;
      Node&amp; node = a[id];
      a[node.pre].nxt = node.nxt;
      a[node.nxt].pre = node.pre;
      if (node.v == a[node.nxt].v &amp;&amp; node.v != a[node.pre].v)
        nxt_head.push_back(node.nxt);
    }
    cout &lt;&lt; endl;
    swap(head, nxt_head);
  }
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树形DP总结]]></title>
        <id>https://yydcc-blog.github.io/post/shu-xing-dp-zong-jie/</id>
        <link href="https://yydcc-blog.github.io/post/shu-xing-dp-zong-jie/">
        </link>
        <updated>2022-01-09T03:04:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-0-前言">Part 0 前言</h1>
<p>刚学完了树形DP，是时候来总结一下了！😀</p>
<h1 id="part-1-基础部分">Part 1 基础部分</h1>
<p>树形DP就是在树上的DP。</p>
<p>这里先放一下遍历树的模板：</p>
<pre><code class="language-cpp">void dfs(int u,int fa){
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
	}
}
</code></pre>
<p>DP的操作就放在dfs操作的后面，再加上初值和特判，就变成了这样：</p>
<pre><code class="language-cpp">void dfs(int u,int fa){
	|初值定义| 
	if(|特判条件|)|特判操作| 
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
		|DP操作|
	}
}
</code></pre>
<h1 id="part-2-练习部分">Part 2 练习部分</h1>
<h3 id="p1352-没有上司的舞会">P1352 没有上司的舞会</h3>
<p><strong>难度</strong>：★★☆☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，每次只能取父节点的权或子节点的权，求最大的点权和为多少。</p>
<p><strong>分析</strong>：因为能不能区由子节点决定，那么可以设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i  ,0/1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 取（1）和不取（0）的最大权值和。转移方程就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i,1} = f_{j,0} + a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>j</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i,0} = max(f_{j,0} , f_{j,1})+ a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值）。答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">max(f_{root,0},f_{root,1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define maxn 6005
using namespace std;
int n,head[maxn],nex[maxn],to[maxn],f[maxn][2],num[maxn],edgenum;
bool root[maxn];
void addedge(int u,int v){ 
	nex[++edgenum]=head[u];
	to[edgenum]=v;
	head[u]=edgenum;
	root[v]=1;
}
void dp(int u){
	f[u][0]=0;//定义初值 
	f[u][1]=num[u];
	for(int i=head[u];i;i=nex[i]){
		int v=to[i];
		dp(v);
		f[u][0]+=max(f[v][0],f[v][1]);//DP操作 
		f[u][1]+=f[v][0];
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;num[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		addedge(v,u);
	}
	for(int i=1;i&lt;=n;i++)
		if(!root[i]){//是否为根节点 
			dp(i);
			printf(&quot;%d\n&quot;,max(f[i][0],f[i][1]));//输出答案 
			break;
		}
	return 0;
}
</code></pre>
<h3 id="p1122-最大子树和">P1122 最大子树和</h3>
<p><strong>难度</strong>：★☆☆☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，让你求最大的子树权值和。</p>
<p><strong>分析</strong>：因为要求最大子树和，所以设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为以节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 为根的最大子树和。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>f</mi><mi>v</mi></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u = max(0,f_v)+a_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">a_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的权值）。答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">f_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最大值。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct edge {
	int next,to;
} e[100000];
int n,a[100000],head[100000],cnt,f[100000],ans;
void add(int x,int y) {
	e[++cnt].next=head[x];
	e[cnt].to=y;
	head[x]=cnt;
}
void dfs(int u,int fa) {
	f[u]=a[u];
	for(int i=head[u]; i; i=e[i].next) {
		int v=e[i].to;
		if(v!=fa) { 
			dfs(v,u);
			f[u]+=max(0,f[v]);//相加 
		}
	}
	ans=max(ans,f[u]);//记录最大值 
}
int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; i++)
		scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;n; i++) {
		int x,y; 
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="p2015-二叉苹果树">P2015 二叉苹果树</h3>
<p><strong>难度</strong>：★★★☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的二叉树，求一颗有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 条边的子树的最大点权和。</p>
<p><strong>分析</strong>：通过样例可以看出这是一道树上的 <a href="https://baike.baidu.com/item/01%E8%83%8C%E5%8C%85/4301245?fr=aladdin">01背包</a> 题目，通过类比思想把状态转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{x,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示当前节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的子树上保留 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 条边的最大点权和。转移就变成了这样：</p>
<pre><code class="language-cpp">for(int j=q;j&gt;=1;j--)
	for(int k=j-1;k&gt;=0;k--)
		f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
</code></pre>
<p>搜索，每一个点找出以它为根节点的1~q的最大利益，除叶节点外。因为连接父节点和子节点还有一条边，所以父节点自己留的可用边-1。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,q;
int f[1005][1005],edgenum,len[1009],head[1009],to[1005],nxt[1005];
void addedge(int u,int v,int l){
	nxt[++edgenum]=head[u];
	to[edgenum]=v;
	len[edgenum]=l;
	head[u]=edgenum;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		used[v]=1;
		dfs(v,u);
		for(int j=q;j&gt;=1;j--)//01背包要倒着做 
			for(int k=j-1;k&gt;=0;k--)
				f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
	}
}

int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
	for(int i=1;i&lt;n;i++){
		int x,y,z;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);//双向建边 
		addedge(y,x,z);
	}
	dfs(1,0);
	printf(&quot;%d&quot;,f[1][q]);
	return 0;
}
</code></pre>
<h3 id="p2014-ctsc1997选课">P2014 [CTSC1997]选课</h3>
<p><strong>难度</strong>：★★★☆☆</p>
<p><strong>题目大意</strong>：给你一棵带点权的树，求一棵有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 个点的子树的最大权值和。</p>
<p><strong>分析</strong>：跟上面一题差不多，只是变成了单向边。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=305,M=2001;
int f[N][N],edgenum,n,m;
int head[M],nxt[M],to[M];
void addedge(int u,int v){
    nxt[++edgenum]=head[u];
    to[edgenum]=v;
    head[u]=edgenum;
}
void dp(int x){
    for(int e=head[x];e;e=nxt[e]){
        int v=to[e];
        dp(v);
        for(int i=m+1;i&gt;1;i--)
            for(int j=i-1;j&gt;=1;j--)
                f[x][i]=max(f[x][i],f[x][i-j]+f[v][j]);
    }
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        f[i][1]=b;
        addedge(a,i);
    }
    dp(0);
    printf(&quot;%d\n&quot;,f[0][m+1]);
    return 0;
}
</code></pre>
<h3 id="p1273-有线电视网">P1273 有线电视网</h3>
<p><strong>难度</strong>：★★★★☆</p>
<p><strong>题目大意</strong>：选出一个节点数量最多的叶子节点的集合，使这些点到根节点的路径上的权值和减去集合中所有的点的权值大于等于零。</p>
<p><strong>分析</strong>：设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树中，选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个叶子节点，点权-边权的最大值。<code>dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);</code>，最后找第一个大于等于零的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 即为答案。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,head[3010],edgenum,val[3010],dp[3010][3010];
struct node {
	int to,next,w;
} edge[10000];
void adde(int u,int v,int w) {
	edge[++edgenum].to=v;
	edge[edgenum].next=head[u];
	edge[edgenum].w=w;
	head[u]=edgenum;
}
int dfs(int u) {
	if(u&gt;n-m) {
		dp[u][1]=val[u];
		return 1;
	}
	int sum=0,t;
	for(int e=head[u]; e; e=edge[e].next) {
		int v=edge[e].to;
		t=dfs(v);
		sum+=t;
		for(int j=sum; j&gt;0; j--)
			for(int i=1; i&lt;=t; i++)
				if(j-i&gt;=0) dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);
	}
	return sum;
}
int main() {
	memset(dp,~0x3f,sizeof(dp));
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int u=1; u&lt;=n-m; u++) {
		int size,v,w;
		scanf(&quot;%d&quot;,&amp;size);
		for(int j=1; j&lt;=size; j++) {
			scanf(&quot;%d%d&quot;,&amp;v,&amp;w);
			adde(u,v,w);
		}
	}
	for(int i=n-m+1; i&lt;=n; i++)
		scanf(&quot;%d&quot;,&amp;val[i]);
	for (int i=1; i&lt;=n; i++)
		dp[i][0]=0;
	dfs(1);
	for (int i=m; i&gt;=1; i--)
		if (dp[1][i]&gt;=0) {
			printf(&quot;%d&quot;,i);
			break;
		}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的几种存储方式]]></title>
        <id>https://yydcc-blog.github.io/post/tu-de-ji-chong-cun-chu-fang-shi/</id>
        <link href="https://yydcc-blog.github.io/post/tu-de-ji-chong-cun-chu-fang-shi/">
        </link>
        <updated>2022-01-09T02:24:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1邻接矩阵">1.邻接矩阵</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190128175511539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcyMTQyMw==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。</p>
<p>例如：用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不为0时表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>有一条边（也可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不为0时表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>有一条长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的边）</p>
<h3 id="实现">实现：</h3>
<pre><code>int x,y,z;//无向图带权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
mp[x][y]=z;
mp[y][x]=z;

int x,y,z;//有向图带权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
mp[x][y]=z;

int x,y;//无向图无权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y);
mp[x][y]=1;
mp[y][x]=1;

int x,y;//有向图无权加边 
scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y);
mp[x][y]=1;
</code></pre>
<h3 id="邻接矩阵的好处">邻接矩阵的好处：</h3>
<p>1.直观、简单、好理解</p>
<p>2.方便检查任意一对定点间是否存在边</p>
<p>3.方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</p>
<p>4.方便计算任一顶点的度</p>
<p>对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。</p>
<p>对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。</p>
<h3 id="邻接矩阵的缺点">邻接矩阵的缺点：</h3>
<p>1.浪费空间（特别是在稀疏图中，有大量空余空间）</p>
<p>2.浪费时间（要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。）</p>
<p>所以我们需要下面这两个：</p>
<h1 id="2邻接表">2.邻接表</h1>
<p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法。</p>
<p>在邻接表中，对图中每个顶点建立一个单链表，第i个单链表中的节点表示依附于顶点i的边（对有向图是以顶点i为尾的边）。每个单链表上附设一个表头节点。</p>
<p>邻接表的特点如下：</p>
<p>1.邻接表表示不唯一。这是因为在每个顶点对应的单链表中，各边节点的链接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。</p>
<p>2.对于有n个顶点和e条边的无向图，其邻接表有n个顶点节点和2e个边节点。显然，在总的边数小于n(n-1)/2的情况下，邻接表比邻接矩阵要节省空间。</p>
<p>3.对于无向图，邻接表的顶点i对应的第i个链表的边节点数目正好是顶点i的度。</p>
<p>4.对于有向图，邻接表的顶点i对应的第i个链表的边节点数目仅仅是顶点i的出度。其入度为邻接表中所有adjvex域值为i的边节点数目。</p>
<h1 id="3链式前向星">3.链式前向星</h1>
<h3 id="1-结构">1. 结构</h3>
<p>这里用两个东西：</p>
<p>1 结构体数组edge存边，edge[i]表示第i条边,</p>
<p>2 head[i]存以i为起点的第一条边(在edge中的下标)</p>
<pre><code class="language-cpp">struct EDGE{
	int next;   //下一条边的存储下标(默认0) 
	int to;     //这条边的终点 
	int w;      //权值 
}edge[500010];
</code></pre>
<h3 id="2增边">2.增边</h3>
<p>若以点i为起点的边新增了一条，在edge中的下标为j.</p>
<p>那么edge[j].next=head[i];然后head[i]=j.</p>
<p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p>
<pre><code class="language-cpp">
void Add(int u, int v, int w) {  //起点u, 终点v, 权值w 
	//cnt为边的计数，从1开始计 
	edge[++cnt].next = head[u];
	edge[cnt].w = w;
	edge[cnt].to = v;
	head[u] = cnt;    //第一条边为当前边 
}
</code></pre>
<h3 id="3-遍历">3. 遍历</h3>
<p>遍历以st为起点的边</p>
<pre><code class="language-c++">for(int i=head[st]; i!=0; i=edge[i].next)
</code></pre>
<p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p>
<h1 id="然后就没有然后了">然后就没有然后了...</h1>
]]></content>
    </entry>
</feed>